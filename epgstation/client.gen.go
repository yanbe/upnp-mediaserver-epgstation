// Package epgstation provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.10.1 DO NOT EDIT.
package epgstation

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// Defines values for ChannelType.
const (
	ChannelTypeBS ChannelType = "BS"

	ChannelTypeCS ChannelType = "CS"

	ChannelTypeGR ChannelType = "GR"

	ChannelTypeSKY ChannelType = "SKY"
)

// Defines values for ProgramAudioSamplingRate.
const (
	ProgramAudioSamplingRateN16000 ProgramAudioSamplingRate = 16000

	ProgramAudioSamplingRateN22050 ProgramAudioSamplingRate = 22050

	ProgramAudioSamplingRateN24000 ProgramAudioSamplingRate = 24000

	ProgramAudioSamplingRateN32000 ProgramAudioSamplingRate = 32000

	ProgramAudioSamplingRateN44100 ProgramAudioSamplingRate = 44100

	ProgramAudioSamplingRateN48000 ProgramAudioSamplingRate = 48000
)

// Defines values for ProgramVideoResolution.
const (
	ProgramVideoResolutionN1080i ProgramVideoResolution = "1080i"

	ProgramVideoResolutionN1080p ProgramVideoResolution = "1080p"

	ProgramVideoResolutionN2160p ProgramVideoResolution = "2160p"

	ProgramVideoResolutionN240p ProgramVideoResolution = "240p"

	ProgramVideoResolutionN4320p ProgramVideoResolution = "4320p"

	ProgramVideoResolutionN480i ProgramVideoResolution = "480i"

	ProgramVideoResolutionN480p ProgramVideoResolution = "480p"

	ProgramVideoResolutionN720p ProgramVideoResolution = "720p"
)

// Defines values for ProgramVideoType.
const (
	ProgramVideoTypeH264 ProgramVideoType = "h.264"

	ProgramVideoTypeH265 ProgramVideoType = "h.265"

	ProgramVideoTypeMpeg2 ProgramVideoType = "mpeg2"
)

// Defines values for StreamType.
const (
	StreamTypeLiveHLS StreamType = "LiveHLS"

	StreamTypeLiveStream StreamType = "LiveStream"

	StreamTypeRecordedHLS StreamType = "RecordedHLS"

	StreamTypeRecordedStream StreamType = "RecordedStream"
)

// Defines values for VideoFileType.
const (
	VideoFileTypeEncoded VideoFileType = "encoded"

	VideoFileTypeTs VideoFileType = "ts"
)

// エンコード手動追加時のオプション
type AddManualEncodeProgramOption struct {
	// 親ディレクトリ以下のディレクトリ設定
	Directory *string `json:"directory,omitempty"`

	// ソースビデオファイルと同じ場所に保存するか
	IsSaveSameDirectory *bool `json:"isSaveSameDirectory,omitempty"`

	// エンコードプリセット名 config encode の name
	Mode string `json:"mode"`

	// 親ディレクトリ名 config recorded の name, isSaveSameDirectory が false の場合は必須
	ParentDir *string `json:"parentDir,omitempty"`

	// 録画済み番組 id
	RecordedId RecordedId `json:"recordedId"`

	// 元ファイルを削除するか
	RemoveOriginal bool `json:"removeOriginal"`

	// ビデオファイル id
	SourceVideoFileId VideoFileId `json:"sourceVideoFileId"`
}

// 録画タグ追加プション
type AddRecordedTagOption struct {
	// 色
	Color string `json:"color"`

	// タグ名
	Name string `json:"name"`
}

// ルール追加プション
type AddRuleOption struct {
	// 予約エンコードオプション
	EncodeOption *ReserveEncodedOption `json:"encodeOption,omitempty"`

	// 時刻指定予約か
	IsTimeSpecification bool `json:"isTimeSpecification"`

	// ルール予約オプション
	ReserveOption RuleReserveOption `json:"reserveOption"`

	// 予約保存オプション
	SaveOption *ReserveSaveOption `json:"saveOption,omitempty"`

	// ルール検索オプション
	SearchOption RuleSearchOption `json:"searchOption"`
}

// エンコード追加成功応答データ
type AddedEncode struct {
	// エンコード id
	EncodeId EncodeId `json:"encodeId"`
}

// タグ追加成功応答データ
type AddedRecordedTag struct {
	// 録画 tag id
	TagId RecordedTagId `json:"tagId"`
}

// 予約成功応答データ
type AddedReserve struct {
	// 予約 id
	ReserveId ReserveId `json:"reserveId"`
}

// ルール追加成功応答データ
type AddedRule struct {
	// ルール id
	RuleId RuleId `json:"ruleId"`
}

// 放送局 id
type ChannelId int

// チャンネル情報
type ChannelItem struct {
	Channel string `json:"channel"`

	// 放送波タイプ
	ChannelType ChannelType `json:"channelType"`

	// 放送局名(半角)
	HalfWidthName string `json:"halfWidthName"`

	// ロゴデータを持っているか
	HasLogoData bool `json:"hasLogoData"`

	// 放送局 id
	Id ChannelId `json:"id"`

	// 放送局名
	Name string `json:"name"`

	// network id
	NetworkId NetworkId `json:"networkId"`

	// service id
	ServiceId ServiceId `json:"serviceId"`
	Type      *float32  `json:"type,omitempty"`
}

// ChannelItems defines model for ChannelItems.
type ChannelItems []ChannelItem

// 放送波タイプ
type ChannelType string

// コンフィグ
type Config struct {
	// 有効な放送波情報
	Broadcast struct {
		BS  bool `json:"BS"`
		CS  bool `json:"CS"`
		GR  bool `json:"GR"`
		SKY bool `json:"SKY"`
	} `json:"broadcast"`

	// エンコードモード
	Encode []string `json:"encode"`

	// 録画済みのエンコード済みファイルのストリーミングが有効か
	IsEnableEncodedRecordedStream bool `json:"isEnableEncodedRecordedStream"`

	// ライブ視聴が有効か
	IsEnableLiveStream bool `json:"isEnableLiveStream"`

	// 録画済みの TS ファイルのストリーミングが有効か
	IsEnableTSRecordedStream bool `json:"isEnableTSRecordedStream"`

	// kodi hosts
	KodiHosts *[]string `json:"kodiHosts,omitempty"`

	// 指定可能な録画ディレクトリ名
	Recorded []string `json:"recorded"`

	// socket.io 通信で使用するポート
	SocketIOPort int `json:"socketIOPort"`

	// ストリーミング設定
	StreamConfig *struct {
		// ライブストリーミング設定
		Live *struct {
			// ライブ HLS ストリーミング設定
			Hls *[]string `json:"hls,omitempty"`

			// ライブ M2TS ストリーミング設定
			M2ts *[]M2TSStreamParam `json:"m2ts,omitempty"`

			// ライブ M2TS Low Latency (mpegts.js 用) ストリーミング設定
			M2tsll *[]string `json:"m2tsll,omitempty"`

			// ライブ MP4 ストリーミング設定
			Mp4 *[]string `json:"mp4,omitempty"`

			// ライブ WebM ストリーミング設定
			Webm *[]string `json:"webm,omitempty"`
		} `json:"live,omitempty"`

		// 録画済みストリーミング設定
		Recorded *struct {
			// 録画エンコード済みファイルのストリーミング設定
			Encoded *struct {
				// 録画エンコード済みファイルの HLS ストリーミング設定
				Hls *[]string `json:"hls,omitempty"`

				// 録画エンコード済みファイルの MP4 ストリーミング設定
				Mp4 *[]string `json:"mp4,omitempty"`

				// 録画エンコード済みファイルの WebM ストリーミング設定
				Webm *[]string `json:"webm,omitempty"`
			} `json:"encoded,omitempty"`

			// 録画済み TS ファイルのストリーミング設定
			Ts *struct {
				// 録画済み TS ファイルの HLS ストリーミング設定
				Hls *[]string `json:"hls,omitempty"`

				// 録画済み TS ファイルの MP4 ストリーミング設定
				Mp4 *[]string `json:"mp4,omitempty"`

				// 録画済み TS ファイルの WebM ストリーミング設定
				Webm *[]string `json:"webm,omitempty"`
			} `json:"ts,omitempty"`
		} `json:"recorded,omitempty"`
	} `json:"streamConfig,omitempty"`

	// URL Scheme 情報
	Urlscheme struct {
		// URL Scheme
		Download URLSchemeInfo `json:"download"`

		// URL Scheme
		M2ts URLSchemeInfo `json:"m2ts"`

		// URL Scheme
		Video URLSchemeInfo `json:"video"`
	} `json:"urlscheme"`
}

// 新規追加する録画番組情報
type CreateNewRecordedOption struct {
	// 放送局 id
	ChannelId ChannelId `json:"channelId"`

	// 番組詳細
	Description *string `json:"description,omitempty"`

	// 時刻 (ms)
	EndAt UnixtimeMS `json:"endAt"`

	// 番組拡張
	Extended *string `json:"extended,omitempty"`

	// ジャンル
	Genre1 *ProgramGenreLv1 `json:"genre1,omitempty"`

	// ジャンル
	Genre2 *ProgramGenreLv1 `json:"genre2,omitempty"`

	// ジャンル
	Genre3 *ProgramGenreLv1 `json:"genre3,omitempty"`

	// 番組名
	Name string `json:"name"`

	// ルール id
	RuleId *RuleId `json:"ruleId,omitempty"`

	// 時刻 (ms)
	StartAt UnixtimeMS `json:"startAt"`

	// サブジャンル
	SubGenre1 *ProgramGenreLv2 `json:"subGenre1,omitempty"`

	// サブジャンル
	SubGenre2 *ProgramGenreLv2 `json:"subGenre2,omitempty"`

	// サブジャンル
	SubGenre3 *ProgramGenreLv2 `json:"subGenre3,omitempty"`
}

// 録画番組情報の新規作成成功応答データ
type CreatedNewRecorded struct {
	// 録画済み番組 id
	RecordedId RecordedId `json:"recordedId"`
}

// ドロップログファイル情報
type DropLogFile struct {
	// ドロップカウント
	DropCnt int `json:"dropCnt"`

	// エラーカウント
	ErrorCnt int `json:"errorCnt"`

	// ドロップログファイル id
	Id DropLogFileId `json:"id"`

	// スクランブルカウント
	ScramblingCnt int `json:"scramblingCnt"`
}

// ドロップログファイル id
type DropLogFileId int

// 手動予約編集オプション
type EditManualReserveOption struct {
	// 末尾切れを許すか
	AllowEndLack bool `json:"allowEndLack"`

	// 予約エンコードオプション
	EncodeOption *ReserveEncodedOption `json:"encodeOption,omitempty"`

	// 予約保存オプション
	SaveOption *ReserveSaveOption `json:"saveOption,omitempty"`
	Tags       *[]RecordedTagId   `json:"tags,omitempty"`
}

// エンコード id
type EncodeId int

// エンコード情報
type EncodeInfo struct {
	RunningItems []EncodeProgramItem `json:"runningItems"`
	WaitItems    []EncodeProgramItem `json:"waitItems"`
}

// エンコードプログラム情報
type EncodeProgramItem struct {
	// エンコード id
	Id EncodeId `json:"id"`

	// ログ
	Log *string `json:"log,omitempty"`

	// エンコード名
	Mode string `json:"mode"`

	// 進捗
	Percent *float32 `json:"percent,omitempty"`

	// 録画番組情報
	Recorded RecordedItem `json:"recorded"`
}

// Error defines model for Error.
type Error struct {
	// HTTPステータスコード
	Code int32 `json:"code"`

	// Error
	Errors *string `json:"errors,omitempty"`

	// エラーメッセージ
	Message string `json:"message"`
}

// ジャンル設定
type Genre struct {
	// ジャンル
	Genre ProgramGenreLv1 `json:"genre"`

	// サブジャンル
	SubGenre *ProgramGenreLv2 `json:"subGenre,omitempty"`
}

// M2TS形式ストリーミングパラメータ
type M2TSStreamParam struct {
	// 無変換か
	IsUnconverted bool `json:"isUnconverted"`

	// 表示名
	Name string `json:"name"`
}

// ManualReserveOption defines model for ManualReserveOption.
type ManualReserveOption struct {
	// Embedded struct due to allOf(#/components/schemas/EditManualReserveOption)
	EditManualReserveOption `yaml:",inline"`
}

// network id
type NetworkId int

// 番組オーディオサンプリングレート
type ProgramAudioSamplingRate int

// ジャンル
type ProgramGenreLv1 int

// サブジャンル
type ProgramGenreLv2 int

// program id
type ProgramId int

// 番組ビデオ解像度
type ProgramVideoResolution string

// 番組ビデオコーデック
type ProgramVideoType string

// recorded が持つ channelId のリスト
type RecordedChannelListItem struct {
	// 放送局 id
	ChannelId ChannelId `json:"channelId"`

	// 録画数
	Cnt int `json:"cnt"`
}

// recorded が持つ genre のリスト
type RecordedGenreListItem struct {
	// 録画数
	Cnt int `json:"cnt"`

	// ジャンル
	Genre ProgramGenreLv1 `json:"genre"`
}

// 録画済み番組 id
type RecordedId int

// 録画番組情報
type RecordedItem struct {
	AudioComponentType *int `json:"audioComponentType,omitempty"`

	// 番組オーディオサンプリングレート
	AudioSamplingRate *ProgramAudioSamplingRate `json:"audioSamplingRate,omitempty"`

	// 放送局 id
	ChannelId *ChannelId `json:"channelId,omitempty"`

	// 番組詳細
	Description *string `json:"description,omitempty"`

	// ドロップログファイル情報
	DropLog *DropLogFile `json:"dropLog,omitempty"`

	// 時刻 (ms)
	EndAt UnixtimeMS `json:"endAt"`

	// 番組拡張
	Extended *string `json:"extended,omitempty"`

	// ジャンル
	Genre1 *ProgramGenreLv1 `json:"genre1,omitempty"`

	// ジャンル
	Genre2 *ProgramGenreLv1 `json:"genre2,omitempty"`

	// ジャンル
	Genre3 *ProgramGenreLv1 `json:"genre3,omitempty"`

	// 録画済み番組 id
	Id RecordedId `json:"id"`

	// エンコード中か
	IsEncoding bool `json:"isEncoding"`

	// 自動録画削除対象外か
	IsProtected bool `json:"isProtected"`

	// 録画中か
	IsRecording bool `json:"isRecording"`

	// 番組名
	Name string `json:"name"`

	// program id
	ProgramId *ProgramId `json:"programId,omitempty"`

	// 番組拡張 (Mirakurun の extended)
	RawExtended *map[string]interface{} `json:"rawExtended,omitempty"`

	// ルール id
	RuleId *RuleId `json:"ruleId,omitempty"`

	// 時刻 (ms)
	StartAt UnixtimeMS `json:"startAt"`

	// サブジャンル
	SubGenre1 *ProgramGenreLv2 `json:"subGenre1,omitempty"`

	// サブジャンル
	SubGenre2 *ProgramGenreLv2 `json:"subGenre2,omitempty"`

	// サブジャンル
	SubGenre3          *ProgramGenreLv2 `json:"subGenre3,omitempty"`
	Tags               *[]RecordedTag   `json:"tags,omitempty"`
	Thumbnails         *[]ThumbnailId   `json:"thumbnails,omitempty"`
	VideoComponentType *int             `json:"videoComponentType,omitempty"`
	VideoFiles         *[]VideoFile     `json:"videoFiles,omitempty"`

	// 番組ビデオ解像度
	VideoResolution    *ProgramVideoResolution `json:"videoResolution,omitempty"`
	VideoStreamContent *int                    `json:"videoStreamContent,omitempty"`

	// 番組ビデオコーデック
	VideoType *ProgramVideoType `json:"videoType,omitempty"`
}

// recorded が持つ検索オプション情報
type RecordedSearchOptions struct {
	Channels []RecordedChannelListItem `json:"channels"`
	Genres   []RecordedGenreListItem   `json:"genres"`
}

// タグ情報
type RecordedTag struct {
	// 色
	Color string `json:"color"`

	// 録画 tag id
	Id RecordedTagId `json:"id"`

	// タグ名
	Name string `json:"name"`
}

// 録画 tag id
type RecordedTagId int

// 録画タグ情報
type RecordedTags struct {
	Tags []RecordedTag `json:"tags"`

	// 予約総件数
	Total int `json:"total"`
}

// 録画情報
type Records struct {
	Records []RecordedItem `json:"records"`

	// 録画総件数
	Total int `json:"total"`
}

// 録画番組とタグの関連付けオプション
type RelateRecordedTagOption struct {
	// 録画済み番組 id
	RecordedId RecordedId `json:"recordedId"`
}

// 予約カウント
type ReserveCnts struct {
	// 競合予約数
	Conflicts int `json:"conflicts"`

	// 通常予約数
	Normal int `json:"normal"`

	// 重複予約数
	Overlaps int `json:"overlaps"`

	// 競合予約数
	Skips int `json:"skips"`
}

// 予約エンコードオプション
type ReserveEncodedOption struct {
	// エンコードモード1ディレクトリ
	Directory1 *string `json:"directory1,omitempty"`

	// エンコードモード2ディレクトリ
	Directory2 *string `json:"directory2,omitempty"`

	// エンコードモード3ディレクトリ
	Directory3 *string `json:"directory3,omitempty"`

	// エンコードモード1親ディレクトリ
	EncodeParentDirectoryName1 *string `json:"encodeParentDirectoryName1,omitempty"`

	// エンコードモード2親ディレクトリ
	EncodeParentDirectoryName2 *string `json:"encodeParentDirectoryName2,omitempty"`

	// エンコードモード3親ディレクトリ
	EncodeParentDirectoryName3 *string `json:"encodeParentDirectoryName3,omitempty"`

	// エンコード後に ts を削除するか
	IsDeleteOriginalAfterEncode bool `json:"isDeleteOriginalAfterEncode"`

	// エンコードモード1
	Mode1 *string `json:"mode1,omitempty"`

	// エンコードモード2
	Mode2 *string `json:"mode2,omitempty"`

	// エンコードモード3
	Mode3 *string `json:"mode3,omitempty"`
}

// 予約 id
type ReserveId int

// 予約番組情報
type ReserveItem struct {
	AllowEndLack       bool `json:"allowEndLack"`
	AudioComponentType *int `json:"audioComponentType,omitempty"`

	// 番組オーディオサンプリングレート
	AudioSamplingRate *ProgramAudioSamplingRate `json:"audioSamplingRate,omitempty"`

	// 放送局 id
	ChannelId                  ChannelId `json:"channelId"`
	Description                *string   `json:"description,omitempty"`
	Directory                  *string   `json:"directory,omitempty"`
	EncodeDirectory1           *string   `json:"encodeDirectory1,omitempty"`
	EncodeDirectory2           *string   `json:"encodeDirectory2,omitempty"`
	EncodeDirectory3           *int      `json:"encodeDirectory3,omitempty"`
	EncodeMode1                *int      `json:"encodeMode1,omitempty"`
	EncodeMode2                *int      `json:"encodeMode2,omitempty"`
	EncodeMode3                *int      `json:"encodeMode3,omitempty"`
	EncodeParentDirectoryName1 *string   `json:"encodeParentDirectoryName1,omitempty"`
	EncodeParentDirectoryName2 *string   `json:"encodeParentDirectoryName2,omitempty"`
	EncodeParentDirectoryName3 *string   `json:"encodeParentDirectoryName3,omitempty"`

	// 時刻 (ms)
	EndAt    UnixtimeMS `json:"endAt"`
	Extended *string    `json:"extended,omitempty"`

	// ジャンル
	Genre1 *ProgramGenreLv1 `json:"genre1,omitempty"`

	// ジャンル
	Genre2 *ProgramGenreLv1 `json:"genre2,omitempty"`

	// ジャンル
	Genre3 *ProgramGenreLv1 `json:"genre3,omitempty"`

	// 予約 id
	Id                          ReserveId `json:"id"`
	IsConflict                  bool      `json:"isConflict"`
	IsDeleteOriginalAfterEncode bool      `json:"isDeleteOriginalAfterEncode"`
	IsOverlap                   bool      `json:"isOverlap"`
	IsSkip                      bool      `json:"isSkip"`
	IsTimeSpecified             bool      `json:"isTimeSpecified"`
	Name                        string    `json:"name"`
	ParentDirectoryName         *string   `json:"parentDirectoryName,omitempty"`

	// program id
	ProgramId      *ProgramId              `json:"programId,omitempty"`
	RawExtended    *map[string]interface{} `json:"rawExtended,omitempty"`
	RecordedFormat *string                 `json:"recordedFormat,omitempty"`

	// ルール id
	RuleId *RuleId `json:"ruleId,omitempty"`

	// 時刻 (ms)
	StartAt UnixtimeMS `json:"startAt"`

	// サブジャンル
	SubGenre1 *ProgramGenreLv2 `json:"subGenre1,omitempty"`

	// サブジャンル
	SubGenre2 *ProgramGenreLv2 `json:"subGenre2,omitempty"`

	// サブジャンル
	SubGenre3          *ProgramGenreLv2 `json:"subGenre3,omitempty"`
	Tags               *[]RecordedTagId `json:"tags,omitempty"`
	VideoComponentType *int             `json:"videoComponentType,omitempty"`

	// 番組ビデオ解像度
	VideoResolution    *ProgramVideoResolution `json:"videoResolution,omitempty"`
	VideoStreamContent *int                    `json:"videoStreamContent,omitempty"`

	// 番組ビデオコーデック
	VideoType *ProgramVideoType `json:"videoType,omitempty"`
}

// 予約リストitem
type ReserveListItem struct {
	// program id
	ProgramId *ProgramId `json:"programId,omitempty"`

	// 予約 id
	ReserveId ReserveId `json:"reserveId"`

	// ルール id
	RuleId *RuleId `json:"ruleId,omitempty"`
}

// 予約, 除外, 重複, 競合の reserveId のリスト
type ReserveLists struct {
	// 予約リストitem
	Conflicts ReserveListItem `json:"conflicts"`

	// 予約リストitem
	Normal ReserveListItem `json:"normal"`

	// 予約リストitem
	Overlaps ReserveListItem `json:"overlaps"`

	// 予約リストitem
	Skips ReserveListItem `json:"skips"`
}

// 予約保存オプション
type ReserveSaveOption struct {
	// 保存ディレクトリ
	Directory *string `json:"directory,omitempty"`

	// 親保存ディレクトリ
	ParentDirectoryName *string `json:"parentDirectoryName,omitempty"`

	// ファイル名フォーマット
	RecordedFormat *string `json:"recordedFormat,omitempty"`
}

// 予約情報
type Reserves struct {
	Reserves []ReserveItem `json:"reserves"`

	// 予約総件数
	Total int `json:"total"`
}

// Rule defines model for Rule.
type Rule struct {
	// Embedded struct due to allOf(#/components/schemas/AddRuleOption)
	AddRuleOption `yaml:",inline"`
}

// ルール id
type RuleId int

// ルールキーワード検索結果
type RuleKeywordInfo struct {
	Items []RuleKeywordItem `json:"items"`
}

// RuleKeywordItem defines model for RuleKeywordItem.
type RuleKeywordItem struct {
	// ルール id
	Id      RuleId `json:"id"`
	Keyword string `json:"keyword"`
}

// ルール予約オプション
type RuleReserveOption struct {
	// 末尾切れを許可するか
	AllowEndLack bool `json:"allowEndLack"`

	// 録画済みの重複番組を排除するか
	AvoidDuplicate bool `json:"avoidDuplicate"`

	// ルールが有効か
	Enable bool `json:"enable"`

	// 重複を避ける期間
	PeriodToAvoidDuplicate *int             `json:"periodToAvoidDuplicate,omitempty"`
	Tags                   *[]RecordedTagId `json:"tags,omitempty"`
}

// ルール検索オプション
type RuleSearchOption struct {
	// BS
	BS *bool `json:"BS,omitempty"`

	// CS
	CS *bool `json:"CS,omitempty"`

	// GR
	GR *bool `json:"GR,omitempty"`

	// SKY
	SKY *bool `json:"SKY,omitempty"`

	// 放送局
	ChannelIds *[]ChannelId `json:"channelIds,omitempty"`

	// 概要 (検索キーワード)
	Description *bool `json:"description,omitempty"`

	// 番組最大時間 (分)
	DurationMax *int `json:"durationMax,omitempty"`

	// 番組最小時間 (分)
	DurationMin *int `json:"durationMin,omitempty"`

	// 詳細 (検索キーワード)
	Extended *bool `json:"extended,omitempty"`

	// ジャンル
	Genres *[]Genre `json:"genres,omitempty"`

	// 概要 (除外検索キーワード)
	IgnoreDescription *bool `json:"ignoreDescription,omitempty"`

	// 詳細 (除外検索キーワード)
	IgnoreExtended *bool `json:"ignoreExtended,omitempty"`

	// 大文字小文字区別有効化 (除外検索キーワード)
	IgnoreKeyCS *bool `json:"ignoreKeyCS,omitempty"`

	// 正規表現 (除外検索キーワード)
	IgnoreKeyRegExp *bool `json:"ignoreKeyRegExp,omitempty"`

	// 除外検索キーワード
	IgnoreKeyword *string `json:"ignoreKeyword,omitempty"`

	// 番組名 (除外検索キーワード)
	IgnoreName *bool `json:"ignoreName,omitempty"`

	// 無料放送か
	IsFree *bool `json:"isFree,omitempty"`

	// 大文字小文字区別有効化 (検索キーワード)
	KeyCS *bool `json:"keyCS,omitempty"`

	// 正規表現 (検索キーワード)
	KeyRegExp *bool `json:"keyRegExp,omitempty"`

	// 検索キーワード
	Keyword *string `json:"keyword,omitempty"`

	// 番組名 (検索キーワード)
	Name *bool `json:"name,omitempty"`

	// 検索対象期間
	SearchPeriods *[]SearchPeriod `json:"searchPeriods,omitempty"`

	// 時刻範囲
	Times *[]SearchTime `json:"times,omitempty"`
}

// ルール情報
type Rules struct {
	Rules []Rule `json:"rules"`

	// ルール総件数
	Total int `json:"total"`
}

// 番組表データ
type Schedule struct {
	// 番組表の放送局データ
	Channel  ScheduleChannleItem  `json:"channel"`
	Programs ScheduleProgramItems `json:"programs"`
}

// 番組表の放送局データ
type ScheduleChannleItem struct {
	// 放送波タイプ
	ChannelType ChannelType `json:"channelType"`

	// ロゴデータを持っているか
	HasLogoData bool `json:"hasLogoData"`

	// 放送局 id
	Id ChannelId `json:"id"`

	// 放送局名
	Name string `json:"name"`

	// network id
	NetworkId NetworkId `json:"networkId"`

	// リモコン番号
	RemoteControlKeyId *int `json:"remoteControlKeyId,omitempty"`

	// service id
	ServiceId ServiceId `json:"serviceId"`
	Type      *float32  `json:"type,omitempty"`
}

// 番組表の番組データ
type ScheduleProgramItem struct {
	AudioComponentType *int `json:"audioComponentType,omitempty"`

	// 番組オーディオサンプリングレート
	AudioSamplingRate *ProgramAudioSamplingRate `json:"audioSamplingRate,omitempty"`

	// 放送局 id
	ChannelId ChannelId `json:"channelId"`

	// 番組詳細
	Description *string `json:"description,omitempty"`

	// 時刻 (ms)
	EndAt UnixtimeMS `json:"endAt"`

	// 番組拡張
	Extended *string `json:"extended,omitempty"`

	// ジャンル
	Genre1 *ProgramGenreLv1 `json:"genre1,omitempty"`

	// ジャンル
	Genre2 *ProgramGenreLv1 `json:"genre2,omitempty"`

	// ジャンル
	Genre3 *ProgramGenreLv1 `json:"genre3,omitempty"`

	// program id
	Id ProgramId `json:"id"`

	// 無料放送か
	IsFree bool `json:"isFree"`

	// 番組名
	Name string `json:"name"`

	// 番組拡張 (Mirakurun の extended)
	RawExtended *map[string]interface{} `json:"rawExtended,omitempty"`

	// 時刻 (ms)
	StartAt UnixtimeMS `json:"startAt"`

	// サブジャンル
	SubGenre1 *ProgramGenreLv2 `json:"subGenre1,omitempty"`

	// サブジャンル
	SubGenre2 *ProgramGenreLv2 `json:"subGenre2,omitempty"`

	// サブジャンル
	SubGenre3          *ProgramGenreLv2 `json:"subGenre3,omitempty"`
	VideoComponentType *int             `json:"videoComponentType,omitempty"`

	// 番組ビデオ解像度
	VideoResolution    *ProgramVideoResolution `json:"videoResolution,omitempty"`
	VideoStreamContent *int                    `json:"videoStreamContent,omitempty"`

	// 番組ビデオコーデック
	VideoType *ProgramVideoType `json:"videoType,omitempty"`
}

// ScheduleProgramItems defines model for ScheduleProgramItems.
type ScheduleProgramItems []ScheduleProgramItem

// 番組検索オプション
type ScheduleSearchOption struct {
	// 半角文字で取得するか
	IsHalfWidth bool `json:"isHalfWidth"`

	// 検索結果取得最大件数
	Limit *float32 `json:"limit,omitempty"`

	// ルール検索オプション
	Option RuleSearchOption `json:"option"`
}

// Schedules defines model for Schedules.
type Schedules []Schedule

// 検索対象期間オプション
type SearchPeriod struct {
	// 時刻 (ms)
	EndAt UnixtimeMS `json:"endAt"`

	// 時刻 (ms)
	StartAt UnixtimeMS `json:"startAt"`
}

// 時刻範囲指定オプション
type SearchTime struct {
	// 開始時刻からの時刻範囲(時) 1 - 23, 時刻予約の場合は秒で時間の長さを指定する 1 ~ 60 * 50 * 24 秒
	Range *int `json:"range,omitempty"`

	// 開始時刻 1 - 23, 時刻予約の場合は 0 時を 0 とした 0 ~ (60 * 50 * 24) - 1 秒までの開始時刻を指定する
	Start *int `json:"start,omitempty"`

	// 曜日指定 0x01, 0x02, 0x04, 0x08, 0x10, 0x20 ,0x40 が日〜土に対応するので and 演算で曜日を指定する
	Week int `json:"week"`
}

// kodiへビデオリンクを送信するときのオプション
type SendVideoLinkToKodiOption struct {
	// config の kodi の name
	KodiName string `json:"kodiName"`
}

// service id
type ServiceId int

// ストリーム開始情報
type StartStreamInfo struct {
	// ストリーム id
	StreamId StreamId `json:"streamId"`
}

// ストレージ情報
type StorageInfo struct {
	Items []StorageItem `json:"items"`
}

// ストレージ使用状況
type StorageItem struct {
	// 空き容量 (byte)
	Available int `json:"available"`

	// ディスク名
	Name string `json:"name"`

	// 総容量 (byte)
	Total int `json:"total"`

	// 使用量 (byte)
	Used int `json:"used"`
}

// ストリーム id
type StreamId int

// StreamInfo defines model for StreamInfo.
type StreamInfo struct {
	Items []StreamInfoItem `json:"items"`
}

// ストリーム情報
type StreamInfoItem struct {
	// 放送局 id
	ChannelId ChannelId `json:"channelId"`

	// ストリーミング番組詳細
	Description *string `json:"description,omitempty"`

	// 時刻 (ms)
	EndAt UnixtimeMS `json:"endAt"`

	// ストリーミング番組拡張
	Extended *string `json:"extended,omitempty"`

	// 放送波が有効か (HLS 形式の場合有効)
	IsEnable bool `json:"isEnable"`

	// ストリーミング設定
	Mode float32 `json:"mode"`

	// ストリーミング番組名
	Name string `json:"name"`

	// 録画済み番組 id
	RecordedId *RecordedId `json:"recordedId,omitempty"`

	// 時刻 (ms)
	StartAt UnixtimeMS `json:"startAt"`

	// ストリーム id
	StreamId StreamId `json:"streamId"`

	// ストリームの種類
	Type StreamType `json:"type"`

	// ビデオファイル id
	VideoFileId *VideoFileId `json:"videoFileId,omitempty"`
}

// ストリームの種類
type StreamType string

// サムネイル id
type ThumbnailId int

// URL Scheme
type URLSchemeInfo struct {
	Android *string `json:"android,omitempty"`
	Ios     *string `json:"ios,omitempty"`
	Mac     *string `json:"mac,omitempty"`
	Win     *string `json:"win,omitempty"`
}

// 時刻 (ms)
type UnixtimeMS int

// ビデオファイルをアップロード
type UploadVideoFileOption struct {
	File string `json:"file"`

	// ビデオファイル形式
	FileType VideoFileType `json:"fileType"`

	// 親保存ディレクトリ
	ParentDirectoryName string `json:"parentDirectoryName"`

	// 録画済み番組 id
	RecordedId RecordedId `json:"recordedId"`

	// 保存ディレクトリ
	SubDirectory *string `json:"subDirectory,omitempty"`

	// 表示名
	ViewName string `json:"viewName"`
}

// バージョン情報
type Version struct {
	Version string `json:"version"`
}

// ビデオファイル情報
type VideoFile struct {
	// ビデオファイル名
	Filename *string `json:"filename,omitempty"`

	// ビデオファイル id
	Id VideoFileId `json:"id"`

	// ビデオ名 (Web上の表示名)
	Name string `json:"name"`

	// ファイルサイズ
	Size int `json:"size"`

	// ビデオファイル形式
	Type VideoFileType `json:"type"`
}

// ビデオファイルの長さ
type VideoFileDuration struct {
	// 動画長(秒)
	Duration float32 `json:"duration"`
}

// ビデオファイル id
type VideoFileId int

// ビデオファイル形式
type VideoFileType string

// 時刻 (ms)
type AddtionTime UnixtimeMS

// Days defines model for Days.
type Days int

// 時刻 (ms)
type EndAt UnixtimeMS

// GetReserveType defines model for GetReserveType.
type GetReserveType interface{}

// IPTVDays defines model for IPTVDays.
type IPTVDays int

// IPTVIsHalfWidth defines model for IPTVIsHalfWidth.
type IPTVIsHalfWidth bool

// IsDownload defines model for IsDownload.
type IsDownload bool

// IsFreeProgram defines model for IsFreeProgram.
type IsFreeProgram bool

// IsHalfWidth defines model for IsHalfWidth.
type IsHalfWidth bool

// IsReverse defines model for IsReverse.
type IsReverse bool

// Limit defines model for Limit.
type Limit int

// LogFileMaxSize defines model for LogFileMaxSize.
type LogFileMaxSize int

// NeedsRawExtended defines model for NeedsRawExtended.
type NeedsRawExtended bool

// Offset defines model for Offset.
type Offset int

// 放送局 id
type PathChannelId ChannelId

// PathDropLogFileId defines model for PathDropLogFileId.
type PathDropLogFileId int

// PathEncodeId defines model for PathEncodeId.
type PathEncodeId int

// program id
type PathProgramId ProgramId

// PathRecordedId defines model for PathRecordedId.
type PathRecordedId int

// PathRecordedTagId defines model for PathRecordedTagId.
type PathRecordedTagId int

// PathReserveId defines model for PathReserveId.
type PathReserveId int

// PathRuleId defines model for PathRuleId.
type PathRuleId int

// ストリーム id
type PathStreamId StreamId

// PathThumbnailId defines model for PathThumbnailId.
type PathThumbnailId int

// PathVideoFileId defines model for PathVideoFileId.
type PathVideoFileId int

// 放送局 id
type QueryChannelId ChannelId

// QueryExcludeRecordedTagId defines model for QueryExcludeRecordedTagId.
type QueryExcludeRecordedTagId []string

// QueryHasOriginalFile defines model for QueryHasOriginalFile.
type QueryHasOriginalFile bool

// QueryKeyword defines model for QueryKeyword.
type QueryKeyword string

// QueryName defines model for QueryName.
type QueryName string

// ジャンル
type QueryProgramGenre ProgramGenreLv1

// 録画済み番組 id
type QueryRecordedId RecordedId

// ルール id
type QueryRuleId RuleId

// 時刻 (ms)
type StartAt UnixtimeMS

// StreamMode defines model for StreamMode.
type StreamMode int

// StreamPlayPosition defines model for StreamPlayPosition.
type StreamPlayPosition int

// RequiredBS defines model for requiredBS.
type RequiredBS bool

// RequiredCS defines model for requiredCS.
type RequiredCS bool

// RequiredGR defines model for requiredGR.
type RequiredGR bool

// RequiredSKY defines model for requiredSKY.
type RequiredSKY bool

// GetDropLogsDropLogFileIdParams defines parameters for GetDropLogsDropLogFileId.
type GetDropLogsDropLogFileIdParams struct {
	// ファイル最大サイズ (kByte)
	Maxsize *LogFileMaxSize `json:"maxsize,omitempty"`
}

// GetEncodeParams defines parameters for GetEncode.
type GetEncodeParams struct {
	// 半角文字で取得するか
	IsHalfWidth IsHalfWidth `json:"isHalfWidth"`
}

// PostEncodeJSONBody defines parameters for PostEncode.
type PostEncodeJSONBody AddManualEncodeProgramOption

// GetIptvChannelM3u8Params defines parameters for GetIptvChannelM3u8.
type GetIptvChannelM3u8Params struct {
	// 半角文字で取得するか
	IsHalfWidth *IPTVIsHalfWidth `json:"isHalfWidth,omitempty"`

	// ストリーミング設定
	Mode StreamMode `json:"mode"`
}

// GetIptvEpgXmlParams defines parameters for GetIptvEpgXml.
type GetIptvEpgXmlParams struct {
	// 半角文字で取得するか
	IsHalfWidth *IPTVIsHalfWidth `json:"isHalfWidth,omitempty"`

	// 取得日数
	Days *IPTVDays `json:"days,omitempty"`
}

// GetRecordedParams defines parameters for GetRecorded.
type GetRecordedParams struct {
	// 半角文字で取得するか
	IsHalfWidth IsHalfWidth `json:"isHalfWidth"`

	// offset
	Offset *Offset `json:"offset,omitempty"`

	// limit
	Limit *Limit `json:"limit,omitempty"`

	// 逆順で取得するか
	IsReverse *IsReverse `json:"isReverse,omitempty"`

	// ルールid
	RuleId *QueryRuleId `json:"ruleId,omitempty"`

	// 放送局 id
	ChannelId *QueryChannelId `json:"channelId,omitempty"`

	// ジャンル
	Genre *QueryProgramGenre `json:"genre,omitempty"`

	// キーワード
	Keyword *QueryKeyword `json:"keyword,omitempty"`

	// オリジナルファイルを含むか
	HasOriginalFile *QueryHasOriginalFile `json:"hasOriginalFile,omitempty"`
}

// PostRecordedJSONBody defines parameters for PostRecorded.
type PostRecordedJSONBody CreateNewRecordedOption

// GetRecordedRecordedIdParams defines parameters for GetRecordedRecordedId.
type GetRecordedRecordedIdParams struct {
	// 半角文字で取得するか
	IsHalfWidth IsHalfWidth `json:"isHalfWidth"`
}

// GetRecordingParams defines parameters for GetRecording.
type GetRecordingParams struct {
	// offset
	Offset *Offset `json:"offset,omitempty"`

	// limit
	Limit *Limit `json:"limit,omitempty"`

	// 半角文字で取得するか
	IsHalfWidth IsHalfWidth `json:"isHalfWidth"`
}

// GetReservesParams defines parameters for GetReserves.
type GetReservesParams struct {
	// offset
	Offset *Offset `json:"offset,omitempty"`

	// limit
	Limit *Limit `json:"limit,omitempty"`

	// 予約情報取得タイプ
	Type *GetReserveType `json:"type,omitempty"`

	// 半角文字で取得するか
	IsHalfWidth IsHalfWidth `json:"isHalfWidth"`

	// ルールid
	RuleId *QueryRuleId `json:"ruleId,omitempty"`
}

// PostReservesJSONBody defines parameters for PostReserves.
type PostReservesJSONBody ManualReserveOption

// GetReservesListsParams defines parameters for GetReservesLists.
type GetReservesListsParams struct {
	// 開始時刻
	StartAt StartAt `json:"startAt"`

	// 終了時刻
	EndAt EndAt `json:"endAt"`
}

// GetReservesReserveIdParams defines parameters for GetReservesReserveId.
type GetReservesReserveIdParams struct {
	// 半角文字で取得するか
	IsHalfWidth IsHalfWidth `json:"isHalfWidth"`
}

// PutReservesReserveIdJSONBody defines parameters for PutReservesReserveId.
type PutReservesReserveIdJSONBody EditManualReserveOption

// GetRulesParams defines parameters for GetRules.
type GetRulesParams struct {
	// offset
	Offset *Offset `json:"offset,omitempty"`

	// limit
	Limit *Limit `json:"limit,omitempty"`

	// 予約情報取得タイプ
	Type *GetReserveType `json:"type,omitempty"`

	// キーワード
	Keyword *QueryKeyword `json:"keyword,omitempty"`
}

// PostRulesJSONBody defines parameters for PostRules.
type PostRulesJSONBody AddRuleOption

// GetRulesKeywordParams defines parameters for GetRulesKeyword.
type GetRulesKeywordParams struct {
	// offset
	Offset *Offset `json:"offset,omitempty"`

	// limit
	Limit *Limit `json:"limit,omitempty"`

	// キーワード
	Keyword *QueryKeyword `json:"keyword,omitempty"`
}

// PostRulesKeywordJSONBody defines parameters for PostRulesKeyword.
type PostRulesKeywordJSONBody AddRuleOption

// PutRulesRuleIdJSONBody defines parameters for PutRulesRuleId.
type PutRulesRuleIdJSONBody AddRuleOption

// GetSchedulesParams defines parameters for GetSchedules.
type GetSchedulesParams struct {
	// 開始時刻
	StartAt StartAt `json:"startAt"`

	// 終了時刻
	EndAt EndAt `json:"endAt"`

	// 半角文字で取得するか
	IsHalfWidth IsHalfWidth `json:"isHalfWidth"`

	// rawExtended が必要か
	NeedsRawExtended *NeedsRawExtended `json:"needsRawExtended,omitempty"`

	// 無料放送のみ取得するか (true: 無料放送, false: 有料放送, 無指定: 全て)
	IsFree *IsFreeProgram `json:"isFree,omitempty"`

	// GR
	GR RequiredGR `json:"GR"`

	// BS
	BS RequiredBS `json:"BS"`

	// CS
	CS RequiredCS `json:"CS"`

	// SKY
	SKY RequiredSKY `json:"SKY"`
}

// GetSchedulesBroadcastingParams defines parameters for GetSchedulesBroadcasting.
type GetSchedulesBroadcastingParams struct {
	// 追加時間 (ms)
	Time *AddtionTime `json:"time,omitempty"`

	// 半角文字で取得するか
	IsHalfWidth IsHalfWidth `json:"isHalfWidth"`
}

// GetSchedulesDetailProgramIdParams defines parameters for GetSchedulesDetailProgramId.
type GetSchedulesDetailProgramIdParams struct {
	// 半角文字で取得するか
	IsHalfWidth IsHalfWidth `json:"isHalfWidth"`
}

// PostSchedulesSearchJSONBody defines parameters for PostSchedulesSearch.
type PostSchedulesSearchJSONBody ScheduleSearchOption

// GetSchedulesChannelIdParams defines parameters for GetSchedulesChannelId.
type GetSchedulesChannelIdParams struct {
	// 開始時刻
	StartAt StartAt `json:"startAt"`

	// 取得日数
	Days Days `json:"days"`

	// 半角文字で取得するか
	IsHalfWidth IsHalfWidth `json:"isHalfWidth"`

	// rawExtended が必要か
	NeedsRawExtended *NeedsRawExtended `json:"needsRawExtended,omitempty"`

	// 無料放送のみ取得するか (true: 無料放送, false: 有料放送, 無指定: 全て)
	IsFree *IsFreeProgram `json:"isFree,omitempty"`
}

// GetStreamsParams defines parameters for GetStreams.
type GetStreamsParams struct {
	// 半角文字で取得するか
	IsHalfWidth IsHalfWidth `json:"isHalfWidth"`
}

// GetStreamsLiveChannelIdHlsParams defines parameters for GetStreamsLiveChannelIdHls.
type GetStreamsLiveChannelIdHlsParams struct {
	// ストリーミング設定
	Mode StreamMode `json:"mode"`
}

// GetStreamsLiveChannelIdM2tsParams defines parameters for GetStreamsLiveChannelIdM2ts.
type GetStreamsLiveChannelIdM2tsParams struct {
	// ストリーミング設定
	Mode StreamMode `json:"mode"`
}

// GetStreamsLiveChannelIdM2tsPlaylistParams defines parameters for GetStreamsLiveChannelIdM2tsPlaylist.
type GetStreamsLiveChannelIdM2tsPlaylistParams struct {
	// ストリーミング設定
	Mode StreamMode `json:"mode"`
}

// GetStreamsLiveChannelIdM2tsllParams defines parameters for GetStreamsLiveChannelIdM2tsll.
type GetStreamsLiveChannelIdM2tsllParams struct {
	// ストリーミング設定
	Mode StreamMode `json:"mode"`
}

// GetStreamsLiveChannelIdMp4Params defines parameters for GetStreamsLiveChannelIdMp4.
type GetStreamsLiveChannelIdMp4Params struct {
	// ストリーミング設定
	Mode StreamMode `json:"mode"`
}

// GetStreamsLiveChannelIdWebmParams defines parameters for GetStreamsLiveChannelIdWebm.
type GetStreamsLiveChannelIdWebmParams struct {
	// ストリーミング設定
	Mode StreamMode `json:"mode"`
}

// GetStreamsRecordedVideoFileIdHlsParams defines parameters for GetStreamsRecordedVideoFileIdHls.
type GetStreamsRecordedVideoFileIdHlsParams struct {
	// 再生位置
	Ss StreamPlayPosition `json:"ss"`

	// ストリーミング設定
	Mode StreamMode `json:"mode"`
}

// GetStreamsRecordedVideoFileIdMp4Params defines parameters for GetStreamsRecordedVideoFileIdMp4.
type GetStreamsRecordedVideoFileIdMp4Params struct {
	// 再生位置
	Ss StreamPlayPosition `json:"ss"`

	// ストリーミング設定
	Mode StreamMode `json:"mode"`
}

// GetStreamsRecordedVideoFileIdWebmParams defines parameters for GetStreamsRecordedVideoFileIdWebm.
type GetStreamsRecordedVideoFileIdWebmParams struct {
	// 再生位置
	Ss StreamPlayPosition `json:"ss"`

	// ストリーミング設定
	Mode StreamMode `json:"mode"`
}

// GetTagsParams defines parameters for GetTags.
type GetTagsParams struct {
	// offset
	Offset *Offset `json:"offset,omitempty"`

	// limit
	Limit *Limit `json:"limit,omitempty"`

	// name
	Name *QueryName `json:"name,omitempty"`

	// 除外する RecordedTagId
	ExcludeTagId *QueryExcludeRecordedTagId `json:"excludeTagId,omitempty"`
}

// PostTagsJSONBody defines parameters for PostTags.
type PostTagsJSONBody AddRecordedTagOption

// PutTagsTagIdJSONBody defines parameters for PutTagsTagId.
type PutTagsTagIdJSONBody AddRecordedTagOption

// DeleteTagsTagIdRelateParams defines parameters for DeleteTagsTagIdRelate.
type DeleteTagsTagIdRelateParams struct {
	// recorded id
	RecordedId *QueryRecordedId `json:"recordedId,omitempty"`
}

// PutTagsTagIdRelateJSONBody defines parameters for PutTagsTagIdRelate.
type PutTagsTagIdRelateJSONBody RelateRecordedTagOption

// GetVideosVideoFileIdParams defines parameters for GetVideosVideoFileId.
type GetVideosVideoFileIdParams struct {
	// ファイルをダウンロードするか
	IsDownload *IsDownload `json:"isDownload,omitempty"`
}

// PostVideosVideoFileIdKodiJSONBody defines parameters for PostVideosVideoFileIdKodi.
type PostVideosVideoFileIdKodiJSONBody SendVideoLinkToKodiOption

// PostEncodeJSONRequestBody defines body for PostEncode for application/json ContentType.
type PostEncodeJSONRequestBody PostEncodeJSONBody

// PostRecordedJSONRequestBody defines body for PostRecorded for application/json ContentType.
type PostRecordedJSONRequestBody PostRecordedJSONBody

// PostReservesJSONRequestBody defines body for PostReserves for application/json ContentType.
type PostReservesJSONRequestBody PostReservesJSONBody

// PutReservesReserveIdJSONRequestBody defines body for PutReservesReserveId for application/json ContentType.
type PutReservesReserveIdJSONRequestBody PutReservesReserveIdJSONBody

// PostRulesJSONRequestBody defines body for PostRules for application/json ContentType.
type PostRulesJSONRequestBody PostRulesJSONBody

// PostRulesKeywordJSONRequestBody defines body for PostRulesKeyword for application/json ContentType.
type PostRulesKeywordJSONRequestBody PostRulesKeywordJSONBody

// PutRulesRuleIdJSONRequestBody defines body for PutRulesRuleId for application/json ContentType.
type PutRulesRuleIdJSONRequestBody PutRulesRuleIdJSONBody

// PostSchedulesSearchJSONRequestBody defines body for PostSchedulesSearch for application/json ContentType.
type PostSchedulesSearchJSONRequestBody PostSchedulesSearchJSONBody

// PostTagsJSONRequestBody defines body for PostTags for application/json ContentType.
type PostTagsJSONRequestBody PostTagsJSONBody

// PutTagsTagIdJSONRequestBody defines body for PutTagsTagId for application/json ContentType.
type PutTagsTagIdJSONRequestBody PutTagsTagIdJSONBody

// PutTagsTagIdRelateJSONRequestBody defines body for PutTagsTagIdRelate for application/json ContentType.
type PutTagsTagIdRelateJSONRequestBody PutTagsTagIdRelateJSONBody

// PostVideosVideoFileIdKodiJSONRequestBody defines body for PostVideosVideoFileIdKodi for application/json ContentType.
type PostVideosVideoFileIdKodiJSONRequestBody PostVideosVideoFileIdKodiJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetChannels request
	GetChannels(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelsChannelIdLogo request
	GetChannelsChannelIdLogo(ctx context.Context, channelId PathChannelId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfig request
	GetConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDropLogsDropLogFileId request
	GetDropLogsDropLogFileId(ctx context.Context, dropLogFileId PathDropLogFileId, params *GetDropLogsDropLogFileIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEncode request
	GetEncode(ctx context.Context, params *GetEncodeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostEncode request with any body
	PostEncodeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostEncode(ctx context.Context, body PostEncodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteEncodeEncodeId request
	DeleteEncodeEncodeId(ctx context.Context, encodeId PathEncodeId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIptvChannelM3u8 request
	GetIptvChannelM3u8(ctx context.Context, params *GetIptvChannelM3u8Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIptvEpgXml request
	GetIptvEpgXml(ctx context.Context, params *GetIptvEpgXmlParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecorded request
	GetRecorded(ctx context.Context, params *GetRecordedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostRecorded request with any body
	PostRecordedWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostRecorded(ctx context.Context, body PostRecordedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostRecordedCleanup request
	PostRecordedCleanup(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecordedOptions request
	GetRecordedOptions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRecordedRecordedId request
	DeleteRecordedRecordedId(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecordedRecordedId request
	GetRecordedRecordedId(ctx context.Context, recordedId PathRecordedId, params *GetRecordedRecordedIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRecordedRecordedIdEncode request
	DeleteRecordedRecordedIdEncode(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutRecordedRecordedIdProtect request
	PutRecordedRecordedIdProtect(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutRecordedRecordedIdUnprotect request
	PutRecordedRecordedIdUnprotect(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecording request
	GetRecording(ctx context.Context, params *GetRecordingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostRecordingResettimer request
	PostRecordingResettimer(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReserves request
	GetReserves(ctx context.Context, params *GetReservesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostReserves request with any body
	PostReservesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostReserves(ctx context.Context, body PostReservesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReservesCnts request
	GetReservesCnts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReservesLists request
	GetReservesLists(ctx context.Context, params *GetReservesListsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostReservesUpdate request
	PostReservesUpdate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteReservesReserveId request
	DeleteReservesReserveId(ctx context.Context, reserveId PathReserveId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReservesReserveId request
	GetReservesReserveId(ctx context.Context, reserveId PathReserveId, params *GetReservesReserveIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutReservesReserveId request with any body
	PutReservesReserveIdWithBody(ctx context.Context, reserveId PathReserveId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutReservesReserveId(ctx context.Context, reserveId PathReserveId, body PutReservesReserveIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteReservesReserveIdOverlap request
	DeleteReservesReserveIdOverlap(ctx context.Context, reserveId PathReserveId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteReservesReserveIdSkip request
	DeleteReservesReserveIdSkip(ctx context.Context, reserveId PathReserveId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRules request
	GetRules(ctx context.Context, params *GetRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostRules request with any body
	PostRulesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostRules(ctx context.Context, body PostRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRulesKeyword request
	GetRulesKeyword(ctx context.Context, params *GetRulesKeywordParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostRulesKeyword request with any body
	PostRulesKeywordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostRulesKeyword(ctx context.Context, body PostRulesKeywordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRulesRuleId request
	DeleteRulesRuleId(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRulesRuleId request
	GetRulesRuleId(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutRulesRuleId request with any body
	PutRulesRuleIdWithBody(ctx context.Context, ruleId PathRuleId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutRulesRuleId(ctx context.Context, ruleId PathRuleId, body PutRulesRuleIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutRulesRuleIdDisable request
	PutRulesRuleIdDisable(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutRulesRuleIdEnable request
	PutRulesRuleIdEnable(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchedules request
	GetSchedules(ctx context.Context, params *GetSchedulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchedulesBroadcasting request
	GetSchedulesBroadcasting(ctx context.Context, params *GetSchedulesBroadcastingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchedulesDetailProgramId request
	GetSchedulesDetailProgramId(ctx context.Context, programId PathProgramId, params *GetSchedulesDetailProgramIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSchedulesSearch request with any body
	PostSchedulesSearchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSchedulesSearch(ctx context.Context, body PostSchedulesSearchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchedulesChannelId request
	GetSchedulesChannelId(ctx context.Context, channelId PathChannelId, params *GetSchedulesChannelIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStorages request
	GetStorages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStreams request
	DeleteStreams(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreams request
	GetStreams(ctx context.Context, params *GetStreamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreamsLiveChannelIdHls request
	GetStreamsLiveChannelIdHls(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdHlsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreamsLiveChannelIdM2ts request
	GetStreamsLiveChannelIdM2ts(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreamsLiveChannelIdM2tsPlaylist request
	GetStreamsLiveChannelIdM2tsPlaylist(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsPlaylistParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreamsLiveChannelIdM2tsll request
	GetStreamsLiveChannelIdM2tsll(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsllParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreamsLiveChannelIdMp4 request
	GetStreamsLiveChannelIdMp4(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdMp4Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreamsLiveChannelIdWebm request
	GetStreamsLiveChannelIdWebm(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdWebmParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreamsRecordedVideoFileIdHls request
	GetStreamsRecordedVideoFileIdHls(ctx context.Context, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdHlsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreamsRecordedVideoFileIdMp4 request
	GetStreamsRecordedVideoFileIdMp4(ctx context.Context, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdMp4Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreamsRecordedVideoFileIdWebm request
	GetStreamsRecordedVideoFileIdWebm(ctx context.Context, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdWebmParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStreamsStreamId request
	DeleteStreamsStreamId(ctx context.Context, streamId PathStreamId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutStreamsStreamIdKeep request
	PutStreamsStreamIdKeep(ctx context.Context, streamId PathStreamId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTags request
	GetTags(ctx context.Context, params *GetTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTags request with any body
	PostTagsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostTags(ctx context.Context, body PostTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTagsTagId request
	DeleteTagsTagId(ctx context.Context, tagId PathRecordedTagId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutTagsTagId request with any body
	PutTagsTagIdWithBody(ctx context.Context, tagId PathRecordedTagId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutTagsTagId(ctx context.Context, tagId PathRecordedTagId, body PutTagsTagIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTagsTagIdRelate request
	DeleteTagsTagIdRelate(ctx context.Context, tagId PathRecordedTagId, params *DeleteTagsTagIdRelateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutTagsTagIdRelate request with any body
	PutTagsTagIdRelateWithBody(ctx context.Context, tagId PathRecordedTagId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutTagsTagIdRelate(ctx context.Context, tagId PathRecordedTagId, body PutTagsTagIdRelateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostThumbnails request
	PostThumbnails(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostThumbnailsCleanup request
	PostThumbnailsCleanup(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostThumbnailsVideosVideoFileId request
	PostThumbnailsVideosVideoFileId(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteThumbnailsThumbnailId request
	DeleteThumbnailsThumbnailId(ctx context.Context, thumbnailId PathThumbnailId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetThumbnailsThumbnailId request
	GetThumbnailsThumbnailId(ctx context.Context, thumbnailId PathThumbnailId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVersion request
	GetVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostVideosUpload request with any body
	PostVideosUploadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVideosVideoFileId request
	DeleteVideosVideoFileId(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVideosVideoFileId request
	GetVideosVideoFileId(ctx context.Context, videoFileId PathVideoFileId, params *GetVideosVideoFileIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVideosVideoFileIdDuration request
	GetVideosVideoFileIdDuration(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostVideosVideoFileIdKodi request with any body
	PostVideosVideoFileIdKodiWithBody(ctx context.Context, videoFileId PathVideoFileId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostVideosVideoFileIdKodi(ctx context.Context, videoFileId PathVideoFileId, body PostVideosVideoFileIdKodiJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVideosVideoFileIdPlaylist request
	GetVideosVideoFileIdPlaylist(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetChannels(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelsChannelIdLogo(ctx context.Context, channelId PathChannelId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelsChannelIdLogoRequest(c.Server, channelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDropLogsDropLogFileId(ctx context.Context, dropLogFileId PathDropLogFileId, params *GetDropLogsDropLogFileIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDropLogsDropLogFileIdRequest(c.Server, dropLogFileId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEncode(ctx context.Context, params *GetEncodeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEncodeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEncodeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEncodeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEncode(ctx context.Context, body PostEncodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEncodeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEncodeEncodeId(ctx context.Context, encodeId PathEncodeId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteEncodeEncodeIdRequest(c.Server, encodeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIptvChannelM3u8(ctx context.Context, params *GetIptvChannelM3u8Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIptvChannelM3u8Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIptvEpgXml(ctx context.Context, params *GetIptvEpgXmlParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIptvEpgXmlRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecorded(ctx context.Context, params *GetRecordedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecordedRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRecordedWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRecordedRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRecorded(ctx context.Context, body PostRecordedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRecordedRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRecordedCleanup(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRecordedCleanupRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecordedOptions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecordedOptionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRecordedRecordedId(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRecordedRecordedIdRequest(c.Server, recordedId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecordedRecordedId(ctx context.Context, recordedId PathRecordedId, params *GetRecordedRecordedIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecordedRecordedIdRequest(c.Server, recordedId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRecordedRecordedIdEncode(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRecordedRecordedIdEncodeRequest(c.Server, recordedId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutRecordedRecordedIdProtect(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutRecordedRecordedIdProtectRequest(c.Server, recordedId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutRecordedRecordedIdUnprotect(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutRecordedRecordedIdUnprotectRequest(c.Server, recordedId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecording(ctx context.Context, params *GetRecordingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecordingRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRecordingResettimer(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRecordingResettimerRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReserves(ctx context.Context, params *GetReservesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReservesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReservesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReservesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReserves(ctx context.Context, body PostReservesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReservesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReservesCnts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReservesCntsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReservesLists(ctx context.Context, params *GetReservesListsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReservesListsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReservesUpdate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReservesUpdateRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteReservesReserveId(ctx context.Context, reserveId PathReserveId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteReservesReserveIdRequest(c.Server, reserveId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReservesReserveId(ctx context.Context, reserveId PathReserveId, params *GetReservesReserveIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReservesReserveIdRequest(c.Server, reserveId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutReservesReserveIdWithBody(ctx context.Context, reserveId PathReserveId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutReservesReserveIdRequestWithBody(c.Server, reserveId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutReservesReserveId(ctx context.Context, reserveId PathReserveId, body PutReservesReserveIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutReservesReserveIdRequest(c.Server, reserveId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteReservesReserveIdOverlap(ctx context.Context, reserveId PathReserveId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteReservesReserveIdOverlapRequest(c.Server, reserveId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteReservesReserveIdSkip(ctx context.Context, reserveId PathReserveId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteReservesReserveIdSkipRequest(c.Server, reserveId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRules(ctx context.Context, params *GetRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRulesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRulesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRules(ctx context.Context, body PostRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRulesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRulesKeyword(ctx context.Context, params *GetRulesKeywordParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRulesKeywordRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRulesKeywordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRulesKeywordRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRulesKeyword(ctx context.Context, body PostRulesKeywordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRulesKeywordRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRulesRuleId(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRulesRuleIdRequest(c.Server, ruleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRulesRuleId(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRulesRuleIdRequest(c.Server, ruleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutRulesRuleIdWithBody(ctx context.Context, ruleId PathRuleId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutRulesRuleIdRequestWithBody(c.Server, ruleId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutRulesRuleId(ctx context.Context, ruleId PathRuleId, body PutRulesRuleIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutRulesRuleIdRequest(c.Server, ruleId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutRulesRuleIdDisable(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutRulesRuleIdDisableRequest(c.Server, ruleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutRulesRuleIdEnable(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutRulesRuleIdEnableRequest(c.Server, ruleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchedules(ctx context.Context, params *GetSchedulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchedulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchedulesBroadcasting(ctx context.Context, params *GetSchedulesBroadcastingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchedulesBroadcastingRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchedulesDetailProgramId(ctx context.Context, programId PathProgramId, params *GetSchedulesDetailProgramIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchedulesDetailProgramIdRequest(c.Server, programId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSchedulesSearchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSchedulesSearchRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSchedulesSearch(ctx context.Context, body PostSchedulesSearchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSchedulesSearchRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchedulesChannelId(ctx context.Context, channelId PathChannelId, params *GetSchedulesChannelIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchedulesChannelIdRequest(c.Server, channelId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStorages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStoragesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStreams(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStreamsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreams(ctx context.Context, params *GetStreamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreamsLiveChannelIdHls(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdHlsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamsLiveChannelIdHlsRequest(c.Server, channelId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreamsLiveChannelIdM2ts(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamsLiveChannelIdM2tsRequest(c.Server, channelId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreamsLiveChannelIdM2tsPlaylist(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsPlaylistParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamsLiveChannelIdM2tsPlaylistRequest(c.Server, channelId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreamsLiveChannelIdM2tsll(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsllParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamsLiveChannelIdM2tsllRequest(c.Server, channelId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreamsLiveChannelIdMp4(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdMp4Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamsLiveChannelIdMp4Request(c.Server, channelId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreamsLiveChannelIdWebm(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdWebmParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamsLiveChannelIdWebmRequest(c.Server, channelId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreamsRecordedVideoFileIdHls(ctx context.Context, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdHlsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamsRecordedVideoFileIdHlsRequest(c.Server, videoFileId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreamsRecordedVideoFileIdMp4(ctx context.Context, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdMp4Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamsRecordedVideoFileIdMp4Request(c.Server, videoFileId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreamsRecordedVideoFileIdWebm(ctx context.Context, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdWebmParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamsRecordedVideoFileIdWebmRequest(c.Server, videoFileId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStreamsStreamId(ctx context.Context, streamId PathStreamId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStreamsStreamIdRequest(c.Server, streamId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutStreamsStreamIdKeep(ctx context.Context, streamId PathStreamId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutStreamsStreamIdKeepRequest(c.Server, streamId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTags(ctx context.Context, params *GetTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTagsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTagsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTagsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTags(ctx context.Context, body PostTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTagsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTagsTagId(ctx context.Context, tagId PathRecordedTagId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTagsTagIdRequest(c.Server, tagId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutTagsTagIdWithBody(ctx context.Context, tagId PathRecordedTagId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutTagsTagIdRequestWithBody(c.Server, tagId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutTagsTagId(ctx context.Context, tagId PathRecordedTagId, body PutTagsTagIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutTagsTagIdRequest(c.Server, tagId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTagsTagIdRelate(ctx context.Context, tagId PathRecordedTagId, params *DeleteTagsTagIdRelateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTagsTagIdRelateRequest(c.Server, tagId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutTagsTagIdRelateWithBody(ctx context.Context, tagId PathRecordedTagId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutTagsTagIdRelateRequestWithBody(c.Server, tagId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutTagsTagIdRelate(ctx context.Context, tagId PathRecordedTagId, body PutTagsTagIdRelateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutTagsTagIdRelateRequest(c.Server, tagId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostThumbnails(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostThumbnailsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostThumbnailsCleanup(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostThumbnailsCleanupRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostThumbnailsVideosVideoFileId(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostThumbnailsVideosVideoFileIdRequest(c.Server, videoFileId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteThumbnailsThumbnailId(ctx context.Context, thumbnailId PathThumbnailId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteThumbnailsThumbnailIdRequest(c.Server, thumbnailId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetThumbnailsThumbnailId(ctx context.Context, thumbnailId PathThumbnailId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetThumbnailsThumbnailIdRequest(c.Server, thumbnailId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVersionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostVideosUploadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostVideosUploadRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVideosVideoFileId(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVideosVideoFileIdRequest(c.Server, videoFileId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVideosVideoFileId(ctx context.Context, videoFileId PathVideoFileId, params *GetVideosVideoFileIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVideosVideoFileIdRequest(c.Server, videoFileId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVideosVideoFileIdDuration(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVideosVideoFileIdDurationRequest(c.Server, videoFileId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostVideosVideoFileIdKodiWithBody(ctx context.Context, videoFileId PathVideoFileId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostVideosVideoFileIdKodiRequestWithBody(c.Server, videoFileId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostVideosVideoFileIdKodi(ctx context.Context, videoFileId PathVideoFileId, body PostVideosVideoFileIdKodiJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostVideosVideoFileIdKodiRequest(c.Server, videoFileId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVideosVideoFileIdPlaylist(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVideosVideoFileIdPlaylistRequest(c.Server, videoFileId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetChannelsRequest generates requests for GetChannels
func NewGetChannelsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChannelsChannelIdLogoRequest generates requests for GetChannelsChannelIdLogo
func NewGetChannelsChannelIdLogoRequest(server string, channelId PathChannelId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelId", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels/%s/logo", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConfigRequest generates requests for GetConfig
func NewGetConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDropLogsDropLogFileIdRequest generates requests for GetDropLogsDropLogFileId
func NewGetDropLogsDropLogFileIdRequest(server string, dropLogFileId PathDropLogFileId, params *GetDropLogsDropLogFileIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dropLogFileId", runtime.ParamLocationPath, dropLogFileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dropLogs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Maxsize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxsize", runtime.ParamLocationQuery, *params.Maxsize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEncodeRequest generates requests for GetEncode
func NewGetEncodeRequest(server string, params *GetEncodeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/encode")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, params.IsHalfWidth); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostEncodeRequest calls the generic PostEncode builder with application/json body
func NewPostEncodeRequest(server string, body PostEncodeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostEncodeRequestWithBody(server, "application/json", bodyReader)
}

// NewPostEncodeRequestWithBody generates requests for PostEncode with any type of body
func NewPostEncodeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/encode")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteEncodeEncodeIdRequest generates requests for DeleteEncodeEncodeId
func NewDeleteEncodeEncodeIdRequest(server string, encodeId PathEncodeId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "encodeId", runtime.ParamLocationPath, encodeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/encode/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIptvChannelM3u8Request generates requests for GetIptvChannelM3u8
func NewGetIptvChannelM3u8Request(server string, params *GetIptvChannelM3u8Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iptv/channel.m3u8")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsHalfWidth != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, *params.IsHalfWidth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIptvEpgXmlRequest generates requests for GetIptvEpgXml
func NewGetIptvEpgXmlRequest(server string, params *GetIptvEpgXmlParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iptv/epg.xml")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsHalfWidth != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, *params.IsHalfWidth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Days != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "days", runtime.ParamLocationQuery, *params.Days); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRecordedRequest generates requests for GetRecorded
func NewGetRecordedRequest(server string, params *GetRecordedParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recorded")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, params.IsHalfWidth); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsReverse != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isReverse", runtime.ParamLocationQuery, *params.IsReverse); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RuleId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ruleId", runtime.ParamLocationQuery, *params.RuleId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ChannelId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channelId", runtime.ParamLocationQuery, *params.ChannelId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Genre != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "genre", runtime.ParamLocationQuery, *params.Genre); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Keyword != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keyword", runtime.ParamLocationQuery, *params.Keyword); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.HasOriginalFile != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasOriginalFile", runtime.ParamLocationQuery, *params.HasOriginalFile); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostRecordedRequest calls the generic PostRecorded builder with application/json body
func NewPostRecordedRequest(server string, body PostRecordedJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostRecordedRequestWithBody(server, "application/json", bodyReader)
}

// NewPostRecordedRequestWithBody generates requests for PostRecorded with any type of body
func NewPostRecordedRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recorded")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostRecordedCleanupRequest generates requests for PostRecordedCleanup
func NewPostRecordedCleanupRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recorded/cleanup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRecordedOptionsRequest generates requests for GetRecordedOptions
func NewGetRecordedOptionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recorded/options")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteRecordedRecordedIdRequest generates requests for DeleteRecordedRecordedId
func NewDeleteRecordedRecordedIdRequest(server string, recordedId PathRecordedId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "recordedId", runtime.ParamLocationPath, recordedId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recorded/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRecordedRecordedIdRequest generates requests for GetRecordedRecordedId
func NewGetRecordedRecordedIdRequest(server string, recordedId PathRecordedId, params *GetRecordedRecordedIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "recordedId", runtime.ParamLocationPath, recordedId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recorded/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, params.IsHalfWidth); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteRecordedRecordedIdEncodeRequest generates requests for DeleteRecordedRecordedIdEncode
func NewDeleteRecordedRecordedIdEncodeRequest(server string, recordedId PathRecordedId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "recordedId", runtime.ParamLocationPath, recordedId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recorded/%s/encode", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutRecordedRecordedIdProtectRequest generates requests for PutRecordedRecordedIdProtect
func NewPutRecordedRecordedIdProtectRequest(server string, recordedId PathRecordedId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "recordedId", runtime.ParamLocationPath, recordedId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recorded/%s/protect", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutRecordedRecordedIdUnprotectRequest generates requests for PutRecordedRecordedIdUnprotect
func NewPutRecordedRecordedIdUnprotectRequest(server string, recordedId PathRecordedId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "recordedId", runtime.ParamLocationPath, recordedId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recorded/%s/unprotect", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRecordingRequest generates requests for GetRecording
func NewGetRecordingRequest(server string, params *GetRecordingParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recording")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, params.IsHalfWidth); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostRecordingResettimerRequest generates requests for PostRecordingResettimer
func NewPostRecordingResettimerRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recording/resettimer")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReservesRequest generates requests for GetReserves
func NewGetReservesRequest(server string, params *GetReservesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reserves")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Type != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, params.IsHalfWidth); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.RuleId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ruleId", runtime.ParamLocationQuery, *params.RuleId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostReservesRequest calls the generic PostReserves builder with application/json body
func NewPostReservesRequest(server string, body PostReservesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostReservesRequestWithBody(server, "application/json", bodyReader)
}

// NewPostReservesRequestWithBody generates requests for PostReserves with any type of body
func NewPostReservesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reserves")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetReservesCntsRequest generates requests for GetReservesCnts
func NewGetReservesCntsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reserves/cnts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReservesListsRequest generates requests for GetReservesLists
func NewGetReservesListsRequest(server string, params *GetReservesListsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reserves/lists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startAt", runtime.ParamLocationQuery, params.StartAt); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endAt", runtime.ParamLocationQuery, params.EndAt); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostReservesUpdateRequest generates requests for PostReservesUpdate
func NewPostReservesUpdateRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reserves/update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteReservesReserveIdRequest generates requests for DeleteReservesReserveId
func NewDeleteReservesReserveIdRequest(server string, reserveId PathReserveId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "reserveId", runtime.ParamLocationPath, reserveId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reserves/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReservesReserveIdRequest generates requests for GetReservesReserveId
func NewGetReservesReserveIdRequest(server string, reserveId PathReserveId, params *GetReservesReserveIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "reserveId", runtime.ParamLocationPath, reserveId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reserves/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, params.IsHalfWidth); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutReservesReserveIdRequest calls the generic PutReservesReserveId builder with application/json body
func NewPutReservesReserveIdRequest(server string, reserveId PathReserveId, body PutReservesReserveIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutReservesReserveIdRequestWithBody(server, reserveId, "application/json", bodyReader)
}

// NewPutReservesReserveIdRequestWithBody generates requests for PutReservesReserveId with any type of body
func NewPutReservesReserveIdRequestWithBody(server string, reserveId PathReserveId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "reserveId", runtime.ParamLocationPath, reserveId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reserves/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteReservesReserveIdOverlapRequest generates requests for DeleteReservesReserveIdOverlap
func NewDeleteReservesReserveIdOverlapRequest(server string, reserveId PathReserveId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "reserveId", runtime.ParamLocationPath, reserveId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reserves/%s/overlap", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteReservesReserveIdSkipRequest generates requests for DeleteReservesReserveIdSkip
func NewDeleteReservesReserveIdSkipRequest(server string, reserveId PathReserveId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "reserveId", runtime.ParamLocationPath, reserveId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reserves/%s/skip", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRulesRequest generates requests for GetRules
func NewGetRulesRequest(server string, params *GetRulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Type != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Keyword != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keyword", runtime.ParamLocationQuery, *params.Keyword); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostRulesRequest calls the generic PostRules builder with application/json body
func NewPostRulesRequest(server string, body PostRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostRulesRequestWithBody(server, "application/json", bodyReader)
}

// NewPostRulesRequestWithBody generates requests for PostRules with any type of body
func NewPostRulesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRulesKeywordRequest generates requests for GetRulesKeyword
func NewGetRulesKeywordRequest(server string, params *GetRulesKeywordParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/keyword")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Keyword != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keyword", runtime.ParamLocationQuery, *params.Keyword); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostRulesKeywordRequest calls the generic PostRulesKeyword builder with application/json body
func NewPostRulesKeywordRequest(server string, body PostRulesKeywordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostRulesKeywordRequestWithBody(server, "application/json", bodyReader)
}

// NewPostRulesKeywordRequestWithBody generates requests for PostRulesKeyword with any type of body
func NewPostRulesKeywordRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/keyword")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRulesRuleIdRequest generates requests for DeleteRulesRuleId
func NewDeleteRulesRuleIdRequest(server string, ruleId PathRuleId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleId", runtime.ParamLocationPath, ruleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRulesRuleIdRequest generates requests for GetRulesRuleId
func NewGetRulesRuleIdRequest(server string, ruleId PathRuleId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleId", runtime.ParamLocationPath, ruleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutRulesRuleIdRequest calls the generic PutRulesRuleId builder with application/json body
func NewPutRulesRuleIdRequest(server string, ruleId PathRuleId, body PutRulesRuleIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutRulesRuleIdRequestWithBody(server, ruleId, "application/json", bodyReader)
}

// NewPutRulesRuleIdRequestWithBody generates requests for PutRulesRuleId with any type of body
func NewPutRulesRuleIdRequestWithBody(server string, ruleId PathRuleId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleId", runtime.ParamLocationPath, ruleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutRulesRuleIdDisableRequest generates requests for PutRulesRuleIdDisable
func NewPutRulesRuleIdDisableRequest(server string, ruleId PathRuleId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleId", runtime.ParamLocationPath, ruleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/disable", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutRulesRuleIdEnableRequest generates requests for PutRulesRuleIdEnable
func NewPutRulesRuleIdEnableRequest(server string, ruleId PathRuleId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleId", runtime.ParamLocationPath, ruleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/enable", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSchedulesRequest generates requests for GetSchedules
func NewGetSchedulesRequest(server string, params *GetSchedulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schedules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startAt", runtime.ParamLocationQuery, params.StartAt); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endAt", runtime.ParamLocationQuery, params.EndAt); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, params.IsHalfWidth); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.NeedsRawExtended != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "needsRawExtended", runtime.ParamLocationQuery, *params.NeedsRawExtended); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsFree != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isFree", runtime.ParamLocationQuery, *params.IsFree); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "GR", runtime.ParamLocationQuery, params.GR); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "BS", runtime.ParamLocationQuery, params.BS); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "CS", runtime.ParamLocationQuery, params.CS); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "SKY", runtime.ParamLocationQuery, params.SKY); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSchedulesBroadcastingRequest generates requests for GetSchedulesBroadcasting
func NewGetSchedulesBroadcastingRequest(server string, params *GetSchedulesBroadcastingParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schedules/broadcasting")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Time != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time", runtime.ParamLocationQuery, *params.Time); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, params.IsHalfWidth); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSchedulesDetailProgramIdRequest generates requests for GetSchedulesDetailProgramId
func NewGetSchedulesDetailProgramIdRequest(server string, programId PathProgramId, params *GetSchedulesDetailProgramIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "programId", runtime.ParamLocationPath, programId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schedules/detail/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, params.IsHalfWidth); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSchedulesSearchRequest calls the generic PostSchedulesSearch builder with application/json body
func NewPostSchedulesSearchRequest(server string, body PostSchedulesSearchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSchedulesSearchRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSchedulesSearchRequestWithBody generates requests for PostSchedulesSearch with any type of body
func NewPostSchedulesSearchRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schedules/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSchedulesChannelIdRequest generates requests for GetSchedulesChannelId
func NewGetSchedulesChannelIdRequest(server string, channelId PathChannelId, params *GetSchedulesChannelIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelId", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schedules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startAt", runtime.ParamLocationQuery, params.StartAt); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "days", runtime.ParamLocationQuery, params.Days); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, params.IsHalfWidth); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.NeedsRawExtended != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "needsRawExtended", runtime.ParamLocationQuery, *params.NeedsRawExtended); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsFree != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isFree", runtime.ParamLocationQuery, *params.IsFree); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStoragesRequest generates requests for GetStorages
func NewGetStoragesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/storages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteStreamsRequest generates requests for DeleteStreams
func NewDeleteStreamsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamsRequest generates requests for GetStreams
func NewGetStreamsRequest(server string, params *GetStreamsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, params.IsHalfWidth); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamsLiveChannelIdHlsRequest generates requests for GetStreamsLiveChannelIdHls
func NewGetStreamsLiveChannelIdHlsRequest(server string, channelId PathChannelId, params *GetStreamsLiveChannelIdHlsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelId", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/live/%s/hls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamsLiveChannelIdM2tsRequest generates requests for GetStreamsLiveChannelIdM2ts
func NewGetStreamsLiveChannelIdM2tsRequest(server string, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelId", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/live/%s/m2ts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamsLiveChannelIdM2tsPlaylistRequest generates requests for GetStreamsLiveChannelIdM2tsPlaylist
func NewGetStreamsLiveChannelIdM2tsPlaylistRequest(server string, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsPlaylistParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelId", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/live/%s/m2ts/playlist", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamsLiveChannelIdM2tsllRequest generates requests for GetStreamsLiveChannelIdM2tsll
func NewGetStreamsLiveChannelIdM2tsllRequest(server string, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsllParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelId", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/live/%s/m2tsll", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamsLiveChannelIdMp4Request generates requests for GetStreamsLiveChannelIdMp4
func NewGetStreamsLiveChannelIdMp4Request(server string, channelId PathChannelId, params *GetStreamsLiveChannelIdMp4Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelId", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/live/%s/mp4", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamsLiveChannelIdWebmRequest generates requests for GetStreamsLiveChannelIdWebm
func NewGetStreamsLiveChannelIdWebmRequest(server string, channelId PathChannelId, params *GetStreamsLiveChannelIdWebmParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelId", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/live/%s/webm", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamsRecordedVideoFileIdHlsRequest generates requests for GetStreamsRecordedVideoFileIdHls
func NewGetStreamsRecordedVideoFileIdHlsRequest(server string, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdHlsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "videoFileId", runtime.ParamLocationPath, videoFileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/recorded/%s/hls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ss", runtime.ParamLocationQuery, params.Ss); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamsRecordedVideoFileIdMp4Request generates requests for GetStreamsRecordedVideoFileIdMp4
func NewGetStreamsRecordedVideoFileIdMp4Request(server string, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdMp4Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "videoFileId", runtime.ParamLocationPath, videoFileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/recorded/%s/mp4", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ss", runtime.ParamLocationQuery, params.Ss); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamsRecordedVideoFileIdWebmRequest generates requests for GetStreamsRecordedVideoFileIdWebm
func NewGetStreamsRecordedVideoFileIdWebmRequest(server string, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdWebmParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "videoFileId", runtime.ParamLocationPath, videoFileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/recorded/%s/webm", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ss", runtime.ParamLocationQuery, params.Ss); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteStreamsStreamIdRequest generates requests for DeleteStreamsStreamId
func NewDeleteStreamsStreamIdRequest(server string, streamId PathStreamId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "streamId", runtime.ParamLocationPath, streamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutStreamsStreamIdKeepRequest generates requests for PutStreamsStreamIdKeep
func NewPutStreamsStreamIdKeepRequest(server string, streamId PathStreamId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "streamId", runtime.ParamLocationPath, streamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/%s/keep", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTagsRequest generates requests for GetTags
func NewGetTagsRequest(server string, params *GetTagsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Name != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExcludeTagId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeTagId", runtime.ParamLocationQuery, *params.ExcludeTagId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostTagsRequest calls the generic PostTags builder with application/json body
func NewPostTagsRequest(server string, body PostTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostTagsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostTagsRequestWithBody generates requests for PostTags with any type of body
func NewPostTagsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTagsTagIdRequest generates requests for DeleteTagsTagId
func NewDeleteTagsTagIdRequest(server string, tagId PathRecordedTagId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tagId", runtime.ParamLocationPath, tagId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutTagsTagIdRequest calls the generic PutTagsTagId builder with application/json body
func NewPutTagsTagIdRequest(server string, tagId PathRecordedTagId, body PutTagsTagIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutTagsTagIdRequestWithBody(server, tagId, "application/json", bodyReader)
}

// NewPutTagsTagIdRequestWithBody generates requests for PutTagsTagId with any type of body
func NewPutTagsTagIdRequestWithBody(server string, tagId PathRecordedTagId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tagId", runtime.ParamLocationPath, tagId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTagsTagIdRelateRequest generates requests for DeleteTagsTagIdRelate
func NewDeleteTagsTagIdRelateRequest(server string, tagId PathRecordedTagId, params *DeleteTagsTagIdRelateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tagId", runtime.ParamLocationPath, tagId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags/%s/relate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.RecordedId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "recordedId", runtime.ParamLocationQuery, *params.RecordedId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutTagsTagIdRelateRequest calls the generic PutTagsTagIdRelate builder with application/json body
func NewPutTagsTagIdRelateRequest(server string, tagId PathRecordedTagId, body PutTagsTagIdRelateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutTagsTagIdRelateRequestWithBody(server, tagId, "application/json", bodyReader)
}

// NewPutTagsTagIdRelateRequestWithBody generates requests for PutTagsTagIdRelate with any type of body
func NewPutTagsTagIdRelateRequestWithBody(server string, tagId PathRecordedTagId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tagId", runtime.ParamLocationPath, tagId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags/%s/relate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostThumbnailsRequest generates requests for PostThumbnails
func NewPostThumbnailsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/thumbnails")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostThumbnailsCleanupRequest generates requests for PostThumbnailsCleanup
func NewPostThumbnailsCleanupRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/thumbnails/cleanup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostThumbnailsVideosVideoFileIdRequest generates requests for PostThumbnailsVideosVideoFileId
func NewPostThumbnailsVideosVideoFileIdRequest(server string, videoFileId PathVideoFileId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "videoFileId", runtime.ParamLocationPath, videoFileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/thumbnails/videos/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteThumbnailsThumbnailIdRequest generates requests for DeleteThumbnailsThumbnailId
func NewDeleteThumbnailsThumbnailIdRequest(server string, thumbnailId PathThumbnailId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thumbnailId", runtime.ParamLocationPath, thumbnailId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/thumbnails/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetThumbnailsThumbnailIdRequest generates requests for GetThumbnailsThumbnailId
func NewGetThumbnailsThumbnailIdRequest(server string, thumbnailId PathThumbnailId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thumbnailId", runtime.ParamLocationPath, thumbnailId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/thumbnails/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVersionRequest generates requests for GetVersion
func NewGetVersionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/version")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostVideosUploadRequestWithBody generates requests for PostVideosUpload with any type of body
func NewPostVideosUploadRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/videos/upload")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVideosVideoFileIdRequest generates requests for DeleteVideosVideoFileId
func NewDeleteVideosVideoFileIdRequest(server string, videoFileId PathVideoFileId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "videoFileId", runtime.ParamLocationPath, videoFileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/videos/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVideosVideoFileIdRequest generates requests for GetVideosVideoFileId
func NewGetVideosVideoFileIdRequest(server string, videoFileId PathVideoFileId, params *GetVideosVideoFileIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "videoFileId", runtime.ParamLocationPath, videoFileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/videos/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsDownload != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isDownload", runtime.ParamLocationQuery, *params.IsDownload); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVideosVideoFileIdDurationRequest generates requests for GetVideosVideoFileIdDuration
func NewGetVideosVideoFileIdDurationRequest(server string, videoFileId PathVideoFileId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "videoFileId", runtime.ParamLocationPath, videoFileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/videos/%s/duration", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostVideosVideoFileIdKodiRequest calls the generic PostVideosVideoFileIdKodi builder with application/json body
func NewPostVideosVideoFileIdKodiRequest(server string, videoFileId PathVideoFileId, body PostVideosVideoFileIdKodiJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostVideosVideoFileIdKodiRequestWithBody(server, videoFileId, "application/json", bodyReader)
}

// NewPostVideosVideoFileIdKodiRequestWithBody generates requests for PostVideosVideoFileIdKodi with any type of body
func NewPostVideosVideoFileIdKodiRequestWithBody(server string, videoFileId PathVideoFileId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "videoFileId", runtime.ParamLocationPath, videoFileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/videos/%s/kodi", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVideosVideoFileIdPlaylistRequest generates requests for GetVideosVideoFileIdPlaylist
func NewGetVideosVideoFileIdPlaylistRequest(server string, videoFileId PathVideoFileId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "videoFileId", runtime.ParamLocationPath, videoFileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/videos/%s/playlist", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetChannels request
	GetChannelsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetChannelsResponse, error)

	// GetChannelsChannelIdLogo request
	GetChannelsChannelIdLogoWithResponse(ctx context.Context, channelId PathChannelId, reqEditors ...RequestEditorFn) (*GetChannelsChannelIdLogoResponse, error)

	// GetConfig request
	GetConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigResponse, error)

	// GetDropLogsDropLogFileId request
	GetDropLogsDropLogFileIdWithResponse(ctx context.Context, dropLogFileId PathDropLogFileId, params *GetDropLogsDropLogFileIdParams, reqEditors ...RequestEditorFn) (*GetDropLogsDropLogFileIdResponse, error)

	// GetEncode request
	GetEncodeWithResponse(ctx context.Context, params *GetEncodeParams, reqEditors ...RequestEditorFn) (*GetEncodeResponse, error)

	// PostEncode request with any body
	PostEncodeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostEncodeResponse, error)

	PostEncodeWithResponse(ctx context.Context, body PostEncodeJSONRequestBody, reqEditors ...RequestEditorFn) (*PostEncodeResponse, error)

	// DeleteEncodeEncodeId request
	DeleteEncodeEncodeIdWithResponse(ctx context.Context, encodeId PathEncodeId, reqEditors ...RequestEditorFn) (*DeleteEncodeEncodeIdResponse, error)

	// GetIptvChannelM3u8 request
	GetIptvChannelM3u8WithResponse(ctx context.Context, params *GetIptvChannelM3u8Params, reqEditors ...RequestEditorFn) (*GetIptvChannelM3u8Response, error)

	// GetIptvEpgXml request
	GetIptvEpgXmlWithResponse(ctx context.Context, params *GetIptvEpgXmlParams, reqEditors ...RequestEditorFn) (*GetIptvEpgXmlResponse, error)

	// GetRecorded request
	GetRecordedWithResponse(ctx context.Context, params *GetRecordedParams, reqEditors ...RequestEditorFn) (*GetRecordedResponse, error)

	// PostRecorded request with any body
	PostRecordedWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRecordedResponse, error)

	PostRecordedWithResponse(ctx context.Context, body PostRecordedJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRecordedResponse, error)

	// PostRecordedCleanup request
	PostRecordedCleanupWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostRecordedCleanupResponse, error)

	// GetRecordedOptions request
	GetRecordedOptionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRecordedOptionsResponse, error)

	// DeleteRecordedRecordedId request
	DeleteRecordedRecordedIdWithResponse(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*DeleteRecordedRecordedIdResponse, error)

	// GetRecordedRecordedId request
	GetRecordedRecordedIdWithResponse(ctx context.Context, recordedId PathRecordedId, params *GetRecordedRecordedIdParams, reqEditors ...RequestEditorFn) (*GetRecordedRecordedIdResponse, error)

	// DeleteRecordedRecordedIdEncode request
	DeleteRecordedRecordedIdEncodeWithResponse(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*DeleteRecordedRecordedIdEncodeResponse, error)

	// PutRecordedRecordedIdProtect request
	PutRecordedRecordedIdProtectWithResponse(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*PutRecordedRecordedIdProtectResponse, error)

	// PutRecordedRecordedIdUnprotect request
	PutRecordedRecordedIdUnprotectWithResponse(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*PutRecordedRecordedIdUnprotectResponse, error)

	// GetRecording request
	GetRecordingWithResponse(ctx context.Context, params *GetRecordingParams, reqEditors ...RequestEditorFn) (*GetRecordingResponse, error)

	// PostRecordingResettimer request
	PostRecordingResettimerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostRecordingResettimerResponse, error)

	// GetReserves request
	GetReservesWithResponse(ctx context.Context, params *GetReservesParams, reqEditors ...RequestEditorFn) (*GetReservesResponse, error)

	// PostReserves request with any body
	PostReservesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReservesResponse, error)

	PostReservesWithResponse(ctx context.Context, body PostReservesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReservesResponse, error)

	// GetReservesCnts request
	GetReservesCntsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetReservesCntsResponse, error)

	// GetReservesLists request
	GetReservesListsWithResponse(ctx context.Context, params *GetReservesListsParams, reqEditors ...RequestEditorFn) (*GetReservesListsResponse, error)

	// PostReservesUpdate request
	PostReservesUpdateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostReservesUpdateResponse, error)

	// DeleteReservesReserveId request
	DeleteReservesReserveIdWithResponse(ctx context.Context, reserveId PathReserveId, reqEditors ...RequestEditorFn) (*DeleteReservesReserveIdResponse, error)

	// GetReservesReserveId request
	GetReservesReserveIdWithResponse(ctx context.Context, reserveId PathReserveId, params *GetReservesReserveIdParams, reqEditors ...RequestEditorFn) (*GetReservesReserveIdResponse, error)

	// PutReservesReserveId request with any body
	PutReservesReserveIdWithBodyWithResponse(ctx context.Context, reserveId PathReserveId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutReservesReserveIdResponse, error)

	PutReservesReserveIdWithResponse(ctx context.Context, reserveId PathReserveId, body PutReservesReserveIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutReservesReserveIdResponse, error)

	// DeleteReservesReserveIdOverlap request
	DeleteReservesReserveIdOverlapWithResponse(ctx context.Context, reserveId PathReserveId, reqEditors ...RequestEditorFn) (*DeleteReservesReserveIdOverlapResponse, error)

	// DeleteReservesReserveIdSkip request
	DeleteReservesReserveIdSkipWithResponse(ctx context.Context, reserveId PathReserveId, reqEditors ...RequestEditorFn) (*DeleteReservesReserveIdSkipResponse, error)

	// GetRules request
	GetRulesWithResponse(ctx context.Context, params *GetRulesParams, reqEditors ...RequestEditorFn) (*GetRulesResponse, error)

	// PostRules request with any body
	PostRulesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRulesResponse, error)

	PostRulesWithResponse(ctx context.Context, body PostRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRulesResponse, error)

	// GetRulesKeyword request
	GetRulesKeywordWithResponse(ctx context.Context, params *GetRulesKeywordParams, reqEditors ...RequestEditorFn) (*GetRulesKeywordResponse, error)

	// PostRulesKeyword request with any body
	PostRulesKeywordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRulesKeywordResponse, error)

	PostRulesKeywordWithResponse(ctx context.Context, body PostRulesKeywordJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRulesKeywordResponse, error)

	// DeleteRulesRuleId request
	DeleteRulesRuleIdWithResponse(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*DeleteRulesRuleIdResponse, error)

	// GetRulesRuleId request
	GetRulesRuleIdWithResponse(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*GetRulesRuleIdResponse, error)

	// PutRulesRuleId request with any body
	PutRulesRuleIdWithBodyWithResponse(ctx context.Context, ruleId PathRuleId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutRulesRuleIdResponse, error)

	PutRulesRuleIdWithResponse(ctx context.Context, ruleId PathRuleId, body PutRulesRuleIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutRulesRuleIdResponse, error)

	// PutRulesRuleIdDisable request
	PutRulesRuleIdDisableWithResponse(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*PutRulesRuleIdDisableResponse, error)

	// PutRulesRuleIdEnable request
	PutRulesRuleIdEnableWithResponse(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*PutRulesRuleIdEnableResponse, error)

	// GetSchedules request
	GetSchedulesWithResponse(ctx context.Context, params *GetSchedulesParams, reqEditors ...RequestEditorFn) (*GetSchedulesResponse, error)

	// GetSchedulesBroadcasting request
	GetSchedulesBroadcastingWithResponse(ctx context.Context, params *GetSchedulesBroadcastingParams, reqEditors ...RequestEditorFn) (*GetSchedulesBroadcastingResponse, error)

	// GetSchedulesDetailProgramId request
	GetSchedulesDetailProgramIdWithResponse(ctx context.Context, programId PathProgramId, params *GetSchedulesDetailProgramIdParams, reqEditors ...RequestEditorFn) (*GetSchedulesDetailProgramIdResponse, error)

	// PostSchedulesSearch request with any body
	PostSchedulesSearchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSchedulesSearchResponse, error)

	PostSchedulesSearchWithResponse(ctx context.Context, body PostSchedulesSearchJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSchedulesSearchResponse, error)

	// GetSchedulesChannelId request
	GetSchedulesChannelIdWithResponse(ctx context.Context, channelId PathChannelId, params *GetSchedulesChannelIdParams, reqEditors ...RequestEditorFn) (*GetSchedulesChannelIdResponse, error)

	// GetStorages request
	GetStoragesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStoragesResponse, error)

	// DeleteStreams request
	DeleteStreamsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteStreamsResponse, error)

	// GetStreams request
	GetStreamsWithResponse(ctx context.Context, params *GetStreamsParams, reqEditors ...RequestEditorFn) (*GetStreamsResponse, error)

	// GetStreamsLiveChannelIdHls request
	GetStreamsLiveChannelIdHlsWithResponse(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdHlsParams, reqEditors ...RequestEditorFn) (*GetStreamsLiveChannelIdHlsResponse, error)

	// GetStreamsLiveChannelIdM2ts request
	GetStreamsLiveChannelIdM2tsWithResponse(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsParams, reqEditors ...RequestEditorFn) (*GetStreamsLiveChannelIdM2tsResponse, error)

	// GetStreamsLiveChannelIdM2tsPlaylist request
	GetStreamsLiveChannelIdM2tsPlaylistWithResponse(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsPlaylistParams, reqEditors ...RequestEditorFn) (*GetStreamsLiveChannelIdM2tsPlaylistResponse, error)

	// GetStreamsLiveChannelIdM2tsll request
	GetStreamsLiveChannelIdM2tsllWithResponse(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsllParams, reqEditors ...RequestEditorFn) (*GetStreamsLiveChannelIdM2tsllResponse, error)

	// GetStreamsLiveChannelIdMp4 request
	GetStreamsLiveChannelIdMp4WithResponse(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdMp4Params, reqEditors ...RequestEditorFn) (*GetStreamsLiveChannelIdMp4Response, error)

	// GetStreamsLiveChannelIdWebm request
	GetStreamsLiveChannelIdWebmWithResponse(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdWebmParams, reqEditors ...RequestEditorFn) (*GetStreamsLiveChannelIdWebmResponse, error)

	// GetStreamsRecordedVideoFileIdHls request
	GetStreamsRecordedVideoFileIdHlsWithResponse(ctx context.Context, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdHlsParams, reqEditors ...RequestEditorFn) (*GetStreamsRecordedVideoFileIdHlsResponse, error)

	// GetStreamsRecordedVideoFileIdMp4 request
	GetStreamsRecordedVideoFileIdMp4WithResponse(ctx context.Context, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdMp4Params, reqEditors ...RequestEditorFn) (*GetStreamsRecordedVideoFileIdMp4Response, error)

	// GetStreamsRecordedVideoFileIdWebm request
	GetStreamsRecordedVideoFileIdWebmWithResponse(ctx context.Context, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdWebmParams, reqEditors ...RequestEditorFn) (*GetStreamsRecordedVideoFileIdWebmResponse, error)

	// DeleteStreamsStreamId request
	DeleteStreamsStreamIdWithResponse(ctx context.Context, streamId PathStreamId, reqEditors ...RequestEditorFn) (*DeleteStreamsStreamIdResponse, error)

	// PutStreamsStreamIdKeep request
	PutStreamsStreamIdKeepWithResponse(ctx context.Context, streamId PathStreamId, reqEditors ...RequestEditorFn) (*PutStreamsStreamIdKeepResponse, error)

	// GetTags request
	GetTagsWithResponse(ctx context.Context, params *GetTagsParams, reqEditors ...RequestEditorFn) (*GetTagsResponse, error)

	// PostTags request with any body
	PostTagsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTagsResponse, error)

	PostTagsWithResponse(ctx context.Context, body PostTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTagsResponse, error)

	// DeleteTagsTagId request
	DeleteTagsTagIdWithResponse(ctx context.Context, tagId PathRecordedTagId, reqEditors ...RequestEditorFn) (*DeleteTagsTagIdResponse, error)

	// PutTagsTagId request with any body
	PutTagsTagIdWithBodyWithResponse(ctx context.Context, tagId PathRecordedTagId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutTagsTagIdResponse, error)

	PutTagsTagIdWithResponse(ctx context.Context, tagId PathRecordedTagId, body PutTagsTagIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutTagsTagIdResponse, error)

	// DeleteTagsTagIdRelate request
	DeleteTagsTagIdRelateWithResponse(ctx context.Context, tagId PathRecordedTagId, params *DeleteTagsTagIdRelateParams, reqEditors ...RequestEditorFn) (*DeleteTagsTagIdRelateResponse, error)

	// PutTagsTagIdRelate request with any body
	PutTagsTagIdRelateWithBodyWithResponse(ctx context.Context, tagId PathRecordedTagId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutTagsTagIdRelateResponse, error)

	PutTagsTagIdRelateWithResponse(ctx context.Context, tagId PathRecordedTagId, body PutTagsTagIdRelateJSONRequestBody, reqEditors ...RequestEditorFn) (*PutTagsTagIdRelateResponse, error)

	// PostThumbnails request
	PostThumbnailsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostThumbnailsResponse, error)

	// PostThumbnailsCleanup request
	PostThumbnailsCleanupWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostThumbnailsCleanupResponse, error)

	// PostThumbnailsVideosVideoFileId request
	PostThumbnailsVideosVideoFileIdWithResponse(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*PostThumbnailsVideosVideoFileIdResponse, error)

	// DeleteThumbnailsThumbnailId request
	DeleteThumbnailsThumbnailIdWithResponse(ctx context.Context, thumbnailId PathThumbnailId, reqEditors ...RequestEditorFn) (*DeleteThumbnailsThumbnailIdResponse, error)

	// GetThumbnailsThumbnailId request
	GetThumbnailsThumbnailIdWithResponse(ctx context.Context, thumbnailId PathThumbnailId, reqEditors ...RequestEditorFn) (*GetThumbnailsThumbnailIdResponse, error)

	// GetVersion request
	GetVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVersionResponse, error)

	// PostVideosUpload request with any body
	PostVideosUploadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostVideosUploadResponse, error)

	// DeleteVideosVideoFileId request
	DeleteVideosVideoFileIdWithResponse(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*DeleteVideosVideoFileIdResponse, error)

	// GetVideosVideoFileId request
	GetVideosVideoFileIdWithResponse(ctx context.Context, videoFileId PathVideoFileId, params *GetVideosVideoFileIdParams, reqEditors ...RequestEditorFn) (*GetVideosVideoFileIdResponse, error)

	// GetVideosVideoFileIdDuration request
	GetVideosVideoFileIdDurationWithResponse(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*GetVideosVideoFileIdDurationResponse, error)

	// PostVideosVideoFileIdKodi request with any body
	PostVideosVideoFileIdKodiWithBodyWithResponse(ctx context.Context, videoFileId PathVideoFileId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostVideosVideoFileIdKodiResponse, error)

	PostVideosVideoFileIdKodiWithResponse(ctx context.Context, videoFileId PathVideoFileId, body PostVideosVideoFileIdKodiJSONRequestBody, reqEditors ...RequestEditorFn) (*PostVideosVideoFileIdKodiResponse, error)

	// GetVideosVideoFileIdPlaylist request
	GetVideosVideoFileIdPlaylistWithResponse(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*GetVideosVideoFileIdPlaylistResponse, error)
}

type GetChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChannelItems
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelsChannelIdLogoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetChannelsChannelIdLogoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelsChannelIdLogoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Config
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDropLogsDropLogFileIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetDropLogsDropLogFileIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDropLogsDropLogFileIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEncodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EncodeInfo
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetEncodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEncodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostEncodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AddedEncode
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostEncodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostEncodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEncodeEncodeIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteEncodeEncodeIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEncodeEncodeIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIptvChannelM3u8Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetIptvChannelM3u8Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIptvChannelM3u8Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIptvEpgXmlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetIptvEpgXmlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIptvEpgXmlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecordedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Records
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRecordedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecordedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostRecordedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreatedNewRecorded
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostRecordedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostRecordedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostRecordedCleanupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostRecordedCleanupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostRecordedCleanupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecordedOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecordedSearchOptions
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRecordedOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecordedOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRecordedRecordedIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteRecordedRecordedIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRecordedRecordedIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecordedRecordedIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecordedItem
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRecordedRecordedIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecordedRecordedIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRecordedRecordedIdEncodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteRecordedRecordedIdEncodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRecordedRecordedIdEncodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutRecordedRecordedIdProtectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PutRecordedRecordedIdProtectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutRecordedRecordedIdProtectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutRecordedRecordedIdUnprotectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PutRecordedRecordedIdUnprotectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutRecordedRecordedIdUnprotectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecordingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Records
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRecordingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecordingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostRecordingResettimerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostRecordingResettimerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostRecordingResettimerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReservesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Reserves
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetReservesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReservesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostReservesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AddedReserve
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostReservesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostReservesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReservesCntsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReserveCnts
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetReservesCntsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReservesCntsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReservesListsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReserveLists
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetReservesListsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReservesListsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostReservesUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostReservesUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostReservesUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteReservesReserveIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteReservesReserveIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteReservesReserveIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReservesReserveIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReserveItem
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetReservesReserveIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReservesReserveIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutReservesReserveIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PutReservesReserveIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutReservesReserveIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteReservesReserveIdOverlapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteReservesReserveIdOverlapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteReservesReserveIdOverlapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteReservesReserveIdSkipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteReservesReserveIdSkipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteReservesReserveIdSkipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Rules
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AddedRule
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRulesKeywordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RuleKeywordInfo
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRulesKeywordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRulesKeywordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostRulesKeywordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AddedRule
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostRulesKeywordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostRulesKeywordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRulesRuleIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteRulesRuleIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRulesRuleIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRulesRuleIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Rule
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRulesRuleIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRulesRuleIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutRulesRuleIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PutRulesRuleIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutRulesRuleIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutRulesRuleIdDisableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PutRulesRuleIdDisableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutRulesRuleIdDisableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutRulesRuleIdEnableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PutRulesRuleIdEnableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutRulesRuleIdEnableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchedulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Schedules
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSchedulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchedulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchedulesBroadcastingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Schedules
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSchedulesBroadcastingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchedulesBroadcastingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchedulesDetailProgramIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScheduleProgramItem
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSchedulesDetailProgramIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchedulesDetailProgramIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSchedulesSearchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ScheduleProgramItem
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostSchedulesSearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSchedulesSearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchedulesChannelIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Schedules
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSchedulesChannelIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchedulesChannelIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStoragesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StorageInfo
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetStoragesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStoragesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStreamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteStreamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStreamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StreamInfo
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetStreamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamsLiveChannelIdHlsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StartStreamInfo
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetStreamsLiveChannelIdHlsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamsLiveChannelIdHlsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamsLiveChannelIdM2tsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetStreamsLiveChannelIdM2tsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamsLiveChannelIdM2tsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamsLiveChannelIdM2tsPlaylistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetStreamsLiveChannelIdM2tsPlaylistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamsLiveChannelIdM2tsPlaylistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamsLiveChannelIdM2tsllResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetStreamsLiveChannelIdM2tsllResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamsLiveChannelIdM2tsllResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamsLiveChannelIdMp4Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetStreamsLiveChannelIdMp4Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamsLiveChannelIdMp4Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamsLiveChannelIdWebmResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetStreamsLiveChannelIdWebmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamsLiveChannelIdWebmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamsRecordedVideoFileIdHlsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StartStreamInfo
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetStreamsRecordedVideoFileIdHlsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamsRecordedVideoFileIdHlsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamsRecordedVideoFileIdMp4Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetStreamsRecordedVideoFileIdMp4Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamsRecordedVideoFileIdMp4Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamsRecordedVideoFileIdWebmResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetStreamsRecordedVideoFileIdWebmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamsRecordedVideoFileIdWebmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStreamsStreamIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteStreamsStreamIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStreamsStreamIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutStreamsStreamIdKeepResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PutStreamsStreamIdKeepResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutStreamsStreamIdKeepResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecordedTags
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AddedRecordedTag
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTagsTagIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteTagsTagIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTagsTagIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutTagsTagIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PutTagsTagIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutTagsTagIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTagsTagIdRelateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteTagsTagIdRelateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTagsTagIdRelateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutTagsTagIdRelateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PutTagsTagIdRelateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutTagsTagIdRelateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostThumbnailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostThumbnailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostThumbnailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostThumbnailsCleanupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostThumbnailsCleanupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostThumbnailsCleanupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostThumbnailsVideosVideoFileIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostThumbnailsVideosVideoFileIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostThumbnailsVideosVideoFileIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteThumbnailsThumbnailIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteThumbnailsThumbnailIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteThumbnailsThumbnailIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetThumbnailsThumbnailIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetThumbnailsThumbnailIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetThumbnailsThumbnailIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Version
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostVideosUploadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostVideosUploadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostVideosUploadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVideosVideoFileIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteVideosVideoFileIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVideosVideoFileIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVideosVideoFileIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetVideosVideoFileIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVideosVideoFileIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVideosVideoFileIdDurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VideoFileDuration
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetVideosVideoFileIdDurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVideosVideoFileIdDurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostVideosVideoFileIdKodiResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostVideosVideoFileIdKodiResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostVideosVideoFileIdKodiResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVideosVideoFileIdPlaylistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetVideosVideoFileIdPlaylistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVideosVideoFileIdPlaylistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetChannelsWithResponse request returning *GetChannelsResponse
func (c *ClientWithResponses) GetChannelsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetChannelsResponse, error) {
	rsp, err := c.GetChannels(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChannelsResponse(rsp)
}

// GetChannelsChannelIdLogoWithResponse request returning *GetChannelsChannelIdLogoResponse
func (c *ClientWithResponses) GetChannelsChannelIdLogoWithResponse(ctx context.Context, channelId PathChannelId, reqEditors ...RequestEditorFn) (*GetChannelsChannelIdLogoResponse, error) {
	rsp, err := c.GetChannelsChannelIdLogo(ctx, channelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChannelsChannelIdLogoResponse(rsp)
}

// GetConfigWithResponse request returning *GetConfigResponse
func (c *ClientWithResponses) GetConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigResponse, error) {
	rsp, err := c.GetConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigResponse(rsp)
}

// GetDropLogsDropLogFileIdWithResponse request returning *GetDropLogsDropLogFileIdResponse
func (c *ClientWithResponses) GetDropLogsDropLogFileIdWithResponse(ctx context.Context, dropLogFileId PathDropLogFileId, params *GetDropLogsDropLogFileIdParams, reqEditors ...RequestEditorFn) (*GetDropLogsDropLogFileIdResponse, error) {
	rsp, err := c.GetDropLogsDropLogFileId(ctx, dropLogFileId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDropLogsDropLogFileIdResponse(rsp)
}

// GetEncodeWithResponse request returning *GetEncodeResponse
func (c *ClientWithResponses) GetEncodeWithResponse(ctx context.Context, params *GetEncodeParams, reqEditors ...RequestEditorFn) (*GetEncodeResponse, error) {
	rsp, err := c.GetEncode(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEncodeResponse(rsp)
}

// PostEncodeWithBodyWithResponse request with arbitrary body returning *PostEncodeResponse
func (c *ClientWithResponses) PostEncodeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostEncodeResponse, error) {
	rsp, err := c.PostEncodeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEncodeResponse(rsp)
}

func (c *ClientWithResponses) PostEncodeWithResponse(ctx context.Context, body PostEncodeJSONRequestBody, reqEditors ...RequestEditorFn) (*PostEncodeResponse, error) {
	rsp, err := c.PostEncode(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEncodeResponse(rsp)
}

// DeleteEncodeEncodeIdWithResponse request returning *DeleteEncodeEncodeIdResponse
func (c *ClientWithResponses) DeleteEncodeEncodeIdWithResponse(ctx context.Context, encodeId PathEncodeId, reqEditors ...RequestEditorFn) (*DeleteEncodeEncodeIdResponse, error) {
	rsp, err := c.DeleteEncodeEncodeId(ctx, encodeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteEncodeEncodeIdResponse(rsp)
}

// GetIptvChannelM3u8WithResponse request returning *GetIptvChannelM3u8Response
func (c *ClientWithResponses) GetIptvChannelM3u8WithResponse(ctx context.Context, params *GetIptvChannelM3u8Params, reqEditors ...RequestEditorFn) (*GetIptvChannelM3u8Response, error) {
	rsp, err := c.GetIptvChannelM3u8(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIptvChannelM3u8Response(rsp)
}

// GetIptvEpgXmlWithResponse request returning *GetIptvEpgXmlResponse
func (c *ClientWithResponses) GetIptvEpgXmlWithResponse(ctx context.Context, params *GetIptvEpgXmlParams, reqEditors ...RequestEditorFn) (*GetIptvEpgXmlResponse, error) {
	rsp, err := c.GetIptvEpgXml(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIptvEpgXmlResponse(rsp)
}

// GetRecordedWithResponse request returning *GetRecordedResponse
func (c *ClientWithResponses) GetRecordedWithResponse(ctx context.Context, params *GetRecordedParams, reqEditors ...RequestEditorFn) (*GetRecordedResponse, error) {
	rsp, err := c.GetRecorded(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecordedResponse(rsp)
}

// PostRecordedWithBodyWithResponse request with arbitrary body returning *PostRecordedResponse
func (c *ClientWithResponses) PostRecordedWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRecordedResponse, error) {
	rsp, err := c.PostRecordedWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRecordedResponse(rsp)
}

func (c *ClientWithResponses) PostRecordedWithResponse(ctx context.Context, body PostRecordedJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRecordedResponse, error) {
	rsp, err := c.PostRecorded(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRecordedResponse(rsp)
}

// PostRecordedCleanupWithResponse request returning *PostRecordedCleanupResponse
func (c *ClientWithResponses) PostRecordedCleanupWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostRecordedCleanupResponse, error) {
	rsp, err := c.PostRecordedCleanup(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRecordedCleanupResponse(rsp)
}

// GetRecordedOptionsWithResponse request returning *GetRecordedOptionsResponse
func (c *ClientWithResponses) GetRecordedOptionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRecordedOptionsResponse, error) {
	rsp, err := c.GetRecordedOptions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecordedOptionsResponse(rsp)
}

// DeleteRecordedRecordedIdWithResponse request returning *DeleteRecordedRecordedIdResponse
func (c *ClientWithResponses) DeleteRecordedRecordedIdWithResponse(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*DeleteRecordedRecordedIdResponse, error) {
	rsp, err := c.DeleteRecordedRecordedId(ctx, recordedId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRecordedRecordedIdResponse(rsp)
}

// GetRecordedRecordedIdWithResponse request returning *GetRecordedRecordedIdResponse
func (c *ClientWithResponses) GetRecordedRecordedIdWithResponse(ctx context.Context, recordedId PathRecordedId, params *GetRecordedRecordedIdParams, reqEditors ...RequestEditorFn) (*GetRecordedRecordedIdResponse, error) {
	rsp, err := c.GetRecordedRecordedId(ctx, recordedId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecordedRecordedIdResponse(rsp)
}

// DeleteRecordedRecordedIdEncodeWithResponse request returning *DeleteRecordedRecordedIdEncodeResponse
func (c *ClientWithResponses) DeleteRecordedRecordedIdEncodeWithResponse(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*DeleteRecordedRecordedIdEncodeResponse, error) {
	rsp, err := c.DeleteRecordedRecordedIdEncode(ctx, recordedId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRecordedRecordedIdEncodeResponse(rsp)
}

// PutRecordedRecordedIdProtectWithResponse request returning *PutRecordedRecordedIdProtectResponse
func (c *ClientWithResponses) PutRecordedRecordedIdProtectWithResponse(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*PutRecordedRecordedIdProtectResponse, error) {
	rsp, err := c.PutRecordedRecordedIdProtect(ctx, recordedId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutRecordedRecordedIdProtectResponse(rsp)
}

// PutRecordedRecordedIdUnprotectWithResponse request returning *PutRecordedRecordedIdUnprotectResponse
func (c *ClientWithResponses) PutRecordedRecordedIdUnprotectWithResponse(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*PutRecordedRecordedIdUnprotectResponse, error) {
	rsp, err := c.PutRecordedRecordedIdUnprotect(ctx, recordedId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutRecordedRecordedIdUnprotectResponse(rsp)
}

// GetRecordingWithResponse request returning *GetRecordingResponse
func (c *ClientWithResponses) GetRecordingWithResponse(ctx context.Context, params *GetRecordingParams, reqEditors ...RequestEditorFn) (*GetRecordingResponse, error) {
	rsp, err := c.GetRecording(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecordingResponse(rsp)
}

// PostRecordingResettimerWithResponse request returning *PostRecordingResettimerResponse
func (c *ClientWithResponses) PostRecordingResettimerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostRecordingResettimerResponse, error) {
	rsp, err := c.PostRecordingResettimer(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRecordingResettimerResponse(rsp)
}

// GetReservesWithResponse request returning *GetReservesResponse
func (c *ClientWithResponses) GetReservesWithResponse(ctx context.Context, params *GetReservesParams, reqEditors ...RequestEditorFn) (*GetReservesResponse, error) {
	rsp, err := c.GetReserves(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReservesResponse(rsp)
}

// PostReservesWithBodyWithResponse request with arbitrary body returning *PostReservesResponse
func (c *ClientWithResponses) PostReservesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReservesResponse, error) {
	rsp, err := c.PostReservesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReservesResponse(rsp)
}

func (c *ClientWithResponses) PostReservesWithResponse(ctx context.Context, body PostReservesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReservesResponse, error) {
	rsp, err := c.PostReserves(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReservesResponse(rsp)
}

// GetReservesCntsWithResponse request returning *GetReservesCntsResponse
func (c *ClientWithResponses) GetReservesCntsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetReservesCntsResponse, error) {
	rsp, err := c.GetReservesCnts(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReservesCntsResponse(rsp)
}

// GetReservesListsWithResponse request returning *GetReservesListsResponse
func (c *ClientWithResponses) GetReservesListsWithResponse(ctx context.Context, params *GetReservesListsParams, reqEditors ...RequestEditorFn) (*GetReservesListsResponse, error) {
	rsp, err := c.GetReservesLists(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReservesListsResponse(rsp)
}

// PostReservesUpdateWithResponse request returning *PostReservesUpdateResponse
func (c *ClientWithResponses) PostReservesUpdateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostReservesUpdateResponse, error) {
	rsp, err := c.PostReservesUpdate(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReservesUpdateResponse(rsp)
}

// DeleteReservesReserveIdWithResponse request returning *DeleteReservesReserveIdResponse
func (c *ClientWithResponses) DeleteReservesReserveIdWithResponse(ctx context.Context, reserveId PathReserveId, reqEditors ...RequestEditorFn) (*DeleteReservesReserveIdResponse, error) {
	rsp, err := c.DeleteReservesReserveId(ctx, reserveId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteReservesReserveIdResponse(rsp)
}

// GetReservesReserveIdWithResponse request returning *GetReservesReserveIdResponse
func (c *ClientWithResponses) GetReservesReserveIdWithResponse(ctx context.Context, reserveId PathReserveId, params *GetReservesReserveIdParams, reqEditors ...RequestEditorFn) (*GetReservesReserveIdResponse, error) {
	rsp, err := c.GetReservesReserveId(ctx, reserveId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReservesReserveIdResponse(rsp)
}

// PutReservesReserveIdWithBodyWithResponse request with arbitrary body returning *PutReservesReserveIdResponse
func (c *ClientWithResponses) PutReservesReserveIdWithBodyWithResponse(ctx context.Context, reserveId PathReserveId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutReservesReserveIdResponse, error) {
	rsp, err := c.PutReservesReserveIdWithBody(ctx, reserveId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutReservesReserveIdResponse(rsp)
}

func (c *ClientWithResponses) PutReservesReserveIdWithResponse(ctx context.Context, reserveId PathReserveId, body PutReservesReserveIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutReservesReserveIdResponse, error) {
	rsp, err := c.PutReservesReserveId(ctx, reserveId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutReservesReserveIdResponse(rsp)
}

// DeleteReservesReserveIdOverlapWithResponse request returning *DeleteReservesReserveIdOverlapResponse
func (c *ClientWithResponses) DeleteReservesReserveIdOverlapWithResponse(ctx context.Context, reserveId PathReserveId, reqEditors ...RequestEditorFn) (*DeleteReservesReserveIdOverlapResponse, error) {
	rsp, err := c.DeleteReservesReserveIdOverlap(ctx, reserveId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteReservesReserveIdOverlapResponse(rsp)
}

// DeleteReservesReserveIdSkipWithResponse request returning *DeleteReservesReserveIdSkipResponse
func (c *ClientWithResponses) DeleteReservesReserveIdSkipWithResponse(ctx context.Context, reserveId PathReserveId, reqEditors ...RequestEditorFn) (*DeleteReservesReserveIdSkipResponse, error) {
	rsp, err := c.DeleteReservesReserveIdSkip(ctx, reserveId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteReservesReserveIdSkipResponse(rsp)
}

// GetRulesWithResponse request returning *GetRulesResponse
func (c *ClientWithResponses) GetRulesWithResponse(ctx context.Context, params *GetRulesParams, reqEditors ...RequestEditorFn) (*GetRulesResponse, error) {
	rsp, err := c.GetRules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRulesResponse(rsp)
}

// PostRulesWithBodyWithResponse request with arbitrary body returning *PostRulesResponse
func (c *ClientWithResponses) PostRulesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRulesResponse, error) {
	rsp, err := c.PostRulesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRulesResponse(rsp)
}

func (c *ClientWithResponses) PostRulesWithResponse(ctx context.Context, body PostRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRulesResponse, error) {
	rsp, err := c.PostRules(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRulesResponse(rsp)
}

// GetRulesKeywordWithResponse request returning *GetRulesKeywordResponse
func (c *ClientWithResponses) GetRulesKeywordWithResponse(ctx context.Context, params *GetRulesKeywordParams, reqEditors ...RequestEditorFn) (*GetRulesKeywordResponse, error) {
	rsp, err := c.GetRulesKeyword(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRulesKeywordResponse(rsp)
}

// PostRulesKeywordWithBodyWithResponse request with arbitrary body returning *PostRulesKeywordResponse
func (c *ClientWithResponses) PostRulesKeywordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRulesKeywordResponse, error) {
	rsp, err := c.PostRulesKeywordWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRulesKeywordResponse(rsp)
}

func (c *ClientWithResponses) PostRulesKeywordWithResponse(ctx context.Context, body PostRulesKeywordJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRulesKeywordResponse, error) {
	rsp, err := c.PostRulesKeyword(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRulesKeywordResponse(rsp)
}

// DeleteRulesRuleIdWithResponse request returning *DeleteRulesRuleIdResponse
func (c *ClientWithResponses) DeleteRulesRuleIdWithResponse(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*DeleteRulesRuleIdResponse, error) {
	rsp, err := c.DeleteRulesRuleId(ctx, ruleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRulesRuleIdResponse(rsp)
}

// GetRulesRuleIdWithResponse request returning *GetRulesRuleIdResponse
func (c *ClientWithResponses) GetRulesRuleIdWithResponse(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*GetRulesRuleIdResponse, error) {
	rsp, err := c.GetRulesRuleId(ctx, ruleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRulesRuleIdResponse(rsp)
}

// PutRulesRuleIdWithBodyWithResponse request with arbitrary body returning *PutRulesRuleIdResponse
func (c *ClientWithResponses) PutRulesRuleIdWithBodyWithResponse(ctx context.Context, ruleId PathRuleId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutRulesRuleIdResponse, error) {
	rsp, err := c.PutRulesRuleIdWithBody(ctx, ruleId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutRulesRuleIdResponse(rsp)
}

func (c *ClientWithResponses) PutRulesRuleIdWithResponse(ctx context.Context, ruleId PathRuleId, body PutRulesRuleIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutRulesRuleIdResponse, error) {
	rsp, err := c.PutRulesRuleId(ctx, ruleId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutRulesRuleIdResponse(rsp)
}

// PutRulesRuleIdDisableWithResponse request returning *PutRulesRuleIdDisableResponse
func (c *ClientWithResponses) PutRulesRuleIdDisableWithResponse(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*PutRulesRuleIdDisableResponse, error) {
	rsp, err := c.PutRulesRuleIdDisable(ctx, ruleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutRulesRuleIdDisableResponse(rsp)
}

// PutRulesRuleIdEnableWithResponse request returning *PutRulesRuleIdEnableResponse
func (c *ClientWithResponses) PutRulesRuleIdEnableWithResponse(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*PutRulesRuleIdEnableResponse, error) {
	rsp, err := c.PutRulesRuleIdEnable(ctx, ruleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutRulesRuleIdEnableResponse(rsp)
}

// GetSchedulesWithResponse request returning *GetSchedulesResponse
func (c *ClientWithResponses) GetSchedulesWithResponse(ctx context.Context, params *GetSchedulesParams, reqEditors ...RequestEditorFn) (*GetSchedulesResponse, error) {
	rsp, err := c.GetSchedules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchedulesResponse(rsp)
}

// GetSchedulesBroadcastingWithResponse request returning *GetSchedulesBroadcastingResponse
func (c *ClientWithResponses) GetSchedulesBroadcastingWithResponse(ctx context.Context, params *GetSchedulesBroadcastingParams, reqEditors ...RequestEditorFn) (*GetSchedulesBroadcastingResponse, error) {
	rsp, err := c.GetSchedulesBroadcasting(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchedulesBroadcastingResponse(rsp)
}

// GetSchedulesDetailProgramIdWithResponse request returning *GetSchedulesDetailProgramIdResponse
func (c *ClientWithResponses) GetSchedulesDetailProgramIdWithResponse(ctx context.Context, programId PathProgramId, params *GetSchedulesDetailProgramIdParams, reqEditors ...RequestEditorFn) (*GetSchedulesDetailProgramIdResponse, error) {
	rsp, err := c.GetSchedulesDetailProgramId(ctx, programId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchedulesDetailProgramIdResponse(rsp)
}

// PostSchedulesSearchWithBodyWithResponse request with arbitrary body returning *PostSchedulesSearchResponse
func (c *ClientWithResponses) PostSchedulesSearchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSchedulesSearchResponse, error) {
	rsp, err := c.PostSchedulesSearchWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSchedulesSearchResponse(rsp)
}

func (c *ClientWithResponses) PostSchedulesSearchWithResponse(ctx context.Context, body PostSchedulesSearchJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSchedulesSearchResponse, error) {
	rsp, err := c.PostSchedulesSearch(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSchedulesSearchResponse(rsp)
}

// GetSchedulesChannelIdWithResponse request returning *GetSchedulesChannelIdResponse
func (c *ClientWithResponses) GetSchedulesChannelIdWithResponse(ctx context.Context, channelId PathChannelId, params *GetSchedulesChannelIdParams, reqEditors ...RequestEditorFn) (*GetSchedulesChannelIdResponse, error) {
	rsp, err := c.GetSchedulesChannelId(ctx, channelId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchedulesChannelIdResponse(rsp)
}

// GetStoragesWithResponse request returning *GetStoragesResponse
func (c *ClientWithResponses) GetStoragesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStoragesResponse, error) {
	rsp, err := c.GetStorages(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStoragesResponse(rsp)
}

// DeleteStreamsWithResponse request returning *DeleteStreamsResponse
func (c *ClientWithResponses) DeleteStreamsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteStreamsResponse, error) {
	rsp, err := c.DeleteStreams(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStreamsResponse(rsp)
}

// GetStreamsWithResponse request returning *GetStreamsResponse
func (c *ClientWithResponses) GetStreamsWithResponse(ctx context.Context, params *GetStreamsParams, reqEditors ...RequestEditorFn) (*GetStreamsResponse, error) {
	rsp, err := c.GetStreams(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStreamsResponse(rsp)
}

// GetStreamsLiveChannelIdHlsWithResponse request returning *GetStreamsLiveChannelIdHlsResponse
func (c *ClientWithResponses) GetStreamsLiveChannelIdHlsWithResponse(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdHlsParams, reqEditors ...RequestEditorFn) (*GetStreamsLiveChannelIdHlsResponse, error) {
	rsp, err := c.GetStreamsLiveChannelIdHls(ctx, channelId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStreamsLiveChannelIdHlsResponse(rsp)
}

// GetStreamsLiveChannelIdM2tsWithResponse request returning *GetStreamsLiveChannelIdM2tsResponse
func (c *ClientWithResponses) GetStreamsLiveChannelIdM2tsWithResponse(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsParams, reqEditors ...RequestEditorFn) (*GetStreamsLiveChannelIdM2tsResponse, error) {
	rsp, err := c.GetStreamsLiveChannelIdM2ts(ctx, channelId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStreamsLiveChannelIdM2tsResponse(rsp)
}

// GetStreamsLiveChannelIdM2tsPlaylistWithResponse request returning *GetStreamsLiveChannelIdM2tsPlaylistResponse
func (c *ClientWithResponses) GetStreamsLiveChannelIdM2tsPlaylistWithResponse(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsPlaylistParams, reqEditors ...RequestEditorFn) (*GetStreamsLiveChannelIdM2tsPlaylistResponse, error) {
	rsp, err := c.GetStreamsLiveChannelIdM2tsPlaylist(ctx, channelId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStreamsLiveChannelIdM2tsPlaylistResponse(rsp)
}

// GetStreamsLiveChannelIdM2tsllWithResponse request returning *GetStreamsLiveChannelIdM2tsllResponse
func (c *ClientWithResponses) GetStreamsLiveChannelIdM2tsllWithResponse(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsllParams, reqEditors ...RequestEditorFn) (*GetStreamsLiveChannelIdM2tsllResponse, error) {
	rsp, err := c.GetStreamsLiveChannelIdM2tsll(ctx, channelId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStreamsLiveChannelIdM2tsllResponse(rsp)
}

// GetStreamsLiveChannelIdMp4WithResponse request returning *GetStreamsLiveChannelIdMp4Response
func (c *ClientWithResponses) GetStreamsLiveChannelIdMp4WithResponse(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdMp4Params, reqEditors ...RequestEditorFn) (*GetStreamsLiveChannelIdMp4Response, error) {
	rsp, err := c.GetStreamsLiveChannelIdMp4(ctx, channelId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStreamsLiveChannelIdMp4Response(rsp)
}

// GetStreamsLiveChannelIdWebmWithResponse request returning *GetStreamsLiveChannelIdWebmResponse
func (c *ClientWithResponses) GetStreamsLiveChannelIdWebmWithResponse(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdWebmParams, reqEditors ...RequestEditorFn) (*GetStreamsLiveChannelIdWebmResponse, error) {
	rsp, err := c.GetStreamsLiveChannelIdWebm(ctx, channelId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStreamsLiveChannelIdWebmResponse(rsp)
}

// GetStreamsRecordedVideoFileIdHlsWithResponse request returning *GetStreamsRecordedVideoFileIdHlsResponse
func (c *ClientWithResponses) GetStreamsRecordedVideoFileIdHlsWithResponse(ctx context.Context, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdHlsParams, reqEditors ...RequestEditorFn) (*GetStreamsRecordedVideoFileIdHlsResponse, error) {
	rsp, err := c.GetStreamsRecordedVideoFileIdHls(ctx, videoFileId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStreamsRecordedVideoFileIdHlsResponse(rsp)
}

// GetStreamsRecordedVideoFileIdMp4WithResponse request returning *GetStreamsRecordedVideoFileIdMp4Response
func (c *ClientWithResponses) GetStreamsRecordedVideoFileIdMp4WithResponse(ctx context.Context, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdMp4Params, reqEditors ...RequestEditorFn) (*GetStreamsRecordedVideoFileIdMp4Response, error) {
	rsp, err := c.GetStreamsRecordedVideoFileIdMp4(ctx, videoFileId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStreamsRecordedVideoFileIdMp4Response(rsp)
}

// GetStreamsRecordedVideoFileIdWebmWithResponse request returning *GetStreamsRecordedVideoFileIdWebmResponse
func (c *ClientWithResponses) GetStreamsRecordedVideoFileIdWebmWithResponse(ctx context.Context, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdWebmParams, reqEditors ...RequestEditorFn) (*GetStreamsRecordedVideoFileIdWebmResponse, error) {
	rsp, err := c.GetStreamsRecordedVideoFileIdWebm(ctx, videoFileId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStreamsRecordedVideoFileIdWebmResponse(rsp)
}

// DeleteStreamsStreamIdWithResponse request returning *DeleteStreamsStreamIdResponse
func (c *ClientWithResponses) DeleteStreamsStreamIdWithResponse(ctx context.Context, streamId PathStreamId, reqEditors ...RequestEditorFn) (*DeleteStreamsStreamIdResponse, error) {
	rsp, err := c.DeleteStreamsStreamId(ctx, streamId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStreamsStreamIdResponse(rsp)
}

// PutStreamsStreamIdKeepWithResponse request returning *PutStreamsStreamIdKeepResponse
func (c *ClientWithResponses) PutStreamsStreamIdKeepWithResponse(ctx context.Context, streamId PathStreamId, reqEditors ...RequestEditorFn) (*PutStreamsStreamIdKeepResponse, error) {
	rsp, err := c.PutStreamsStreamIdKeep(ctx, streamId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutStreamsStreamIdKeepResponse(rsp)
}

// GetTagsWithResponse request returning *GetTagsResponse
func (c *ClientWithResponses) GetTagsWithResponse(ctx context.Context, params *GetTagsParams, reqEditors ...RequestEditorFn) (*GetTagsResponse, error) {
	rsp, err := c.GetTags(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTagsResponse(rsp)
}

// PostTagsWithBodyWithResponse request with arbitrary body returning *PostTagsResponse
func (c *ClientWithResponses) PostTagsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTagsResponse, error) {
	rsp, err := c.PostTagsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTagsResponse(rsp)
}

func (c *ClientWithResponses) PostTagsWithResponse(ctx context.Context, body PostTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTagsResponse, error) {
	rsp, err := c.PostTags(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTagsResponse(rsp)
}

// DeleteTagsTagIdWithResponse request returning *DeleteTagsTagIdResponse
func (c *ClientWithResponses) DeleteTagsTagIdWithResponse(ctx context.Context, tagId PathRecordedTagId, reqEditors ...RequestEditorFn) (*DeleteTagsTagIdResponse, error) {
	rsp, err := c.DeleteTagsTagId(ctx, tagId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTagsTagIdResponse(rsp)
}

// PutTagsTagIdWithBodyWithResponse request with arbitrary body returning *PutTagsTagIdResponse
func (c *ClientWithResponses) PutTagsTagIdWithBodyWithResponse(ctx context.Context, tagId PathRecordedTagId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutTagsTagIdResponse, error) {
	rsp, err := c.PutTagsTagIdWithBody(ctx, tagId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutTagsTagIdResponse(rsp)
}

func (c *ClientWithResponses) PutTagsTagIdWithResponse(ctx context.Context, tagId PathRecordedTagId, body PutTagsTagIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutTagsTagIdResponse, error) {
	rsp, err := c.PutTagsTagId(ctx, tagId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutTagsTagIdResponse(rsp)
}

// DeleteTagsTagIdRelateWithResponse request returning *DeleteTagsTagIdRelateResponse
func (c *ClientWithResponses) DeleteTagsTagIdRelateWithResponse(ctx context.Context, tagId PathRecordedTagId, params *DeleteTagsTagIdRelateParams, reqEditors ...RequestEditorFn) (*DeleteTagsTagIdRelateResponse, error) {
	rsp, err := c.DeleteTagsTagIdRelate(ctx, tagId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTagsTagIdRelateResponse(rsp)
}

// PutTagsTagIdRelateWithBodyWithResponse request with arbitrary body returning *PutTagsTagIdRelateResponse
func (c *ClientWithResponses) PutTagsTagIdRelateWithBodyWithResponse(ctx context.Context, tagId PathRecordedTagId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutTagsTagIdRelateResponse, error) {
	rsp, err := c.PutTagsTagIdRelateWithBody(ctx, tagId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutTagsTagIdRelateResponse(rsp)
}

func (c *ClientWithResponses) PutTagsTagIdRelateWithResponse(ctx context.Context, tagId PathRecordedTagId, body PutTagsTagIdRelateJSONRequestBody, reqEditors ...RequestEditorFn) (*PutTagsTagIdRelateResponse, error) {
	rsp, err := c.PutTagsTagIdRelate(ctx, tagId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutTagsTagIdRelateResponse(rsp)
}

// PostThumbnailsWithResponse request returning *PostThumbnailsResponse
func (c *ClientWithResponses) PostThumbnailsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostThumbnailsResponse, error) {
	rsp, err := c.PostThumbnails(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostThumbnailsResponse(rsp)
}

// PostThumbnailsCleanupWithResponse request returning *PostThumbnailsCleanupResponse
func (c *ClientWithResponses) PostThumbnailsCleanupWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostThumbnailsCleanupResponse, error) {
	rsp, err := c.PostThumbnailsCleanup(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostThumbnailsCleanupResponse(rsp)
}

// PostThumbnailsVideosVideoFileIdWithResponse request returning *PostThumbnailsVideosVideoFileIdResponse
func (c *ClientWithResponses) PostThumbnailsVideosVideoFileIdWithResponse(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*PostThumbnailsVideosVideoFileIdResponse, error) {
	rsp, err := c.PostThumbnailsVideosVideoFileId(ctx, videoFileId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostThumbnailsVideosVideoFileIdResponse(rsp)
}

// DeleteThumbnailsThumbnailIdWithResponse request returning *DeleteThumbnailsThumbnailIdResponse
func (c *ClientWithResponses) DeleteThumbnailsThumbnailIdWithResponse(ctx context.Context, thumbnailId PathThumbnailId, reqEditors ...RequestEditorFn) (*DeleteThumbnailsThumbnailIdResponse, error) {
	rsp, err := c.DeleteThumbnailsThumbnailId(ctx, thumbnailId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteThumbnailsThumbnailIdResponse(rsp)
}

// GetThumbnailsThumbnailIdWithResponse request returning *GetThumbnailsThumbnailIdResponse
func (c *ClientWithResponses) GetThumbnailsThumbnailIdWithResponse(ctx context.Context, thumbnailId PathThumbnailId, reqEditors ...RequestEditorFn) (*GetThumbnailsThumbnailIdResponse, error) {
	rsp, err := c.GetThumbnailsThumbnailId(ctx, thumbnailId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetThumbnailsThumbnailIdResponse(rsp)
}

// GetVersionWithResponse request returning *GetVersionResponse
func (c *ClientWithResponses) GetVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVersionResponse, error) {
	rsp, err := c.GetVersion(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVersionResponse(rsp)
}

// PostVideosUploadWithBodyWithResponse request with arbitrary body returning *PostVideosUploadResponse
func (c *ClientWithResponses) PostVideosUploadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostVideosUploadResponse, error) {
	rsp, err := c.PostVideosUploadWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostVideosUploadResponse(rsp)
}

// DeleteVideosVideoFileIdWithResponse request returning *DeleteVideosVideoFileIdResponse
func (c *ClientWithResponses) DeleteVideosVideoFileIdWithResponse(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*DeleteVideosVideoFileIdResponse, error) {
	rsp, err := c.DeleteVideosVideoFileId(ctx, videoFileId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVideosVideoFileIdResponse(rsp)
}

// GetVideosVideoFileIdWithResponse request returning *GetVideosVideoFileIdResponse
func (c *ClientWithResponses) GetVideosVideoFileIdWithResponse(ctx context.Context, videoFileId PathVideoFileId, params *GetVideosVideoFileIdParams, reqEditors ...RequestEditorFn) (*GetVideosVideoFileIdResponse, error) {
	rsp, err := c.GetVideosVideoFileId(ctx, videoFileId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVideosVideoFileIdResponse(rsp)
}

// GetVideosVideoFileIdDurationWithResponse request returning *GetVideosVideoFileIdDurationResponse
func (c *ClientWithResponses) GetVideosVideoFileIdDurationWithResponse(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*GetVideosVideoFileIdDurationResponse, error) {
	rsp, err := c.GetVideosVideoFileIdDuration(ctx, videoFileId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVideosVideoFileIdDurationResponse(rsp)
}

// PostVideosVideoFileIdKodiWithBodyWithResponse request with arbitrary body returning *PostVideosVideoFileIdKodiResponse
func (c *ClientWithResponses) PostVideosVideoFileIdKodiWithBodyWithResponse(ctx context.Context, videoFileId PathVideoFileId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostVideosVideoFileIdKodiResponse, error) {
	rsp, err := c.PostVideosVideoFileIdKodiWithBody(ctx, videoFileId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostVideosVideoFileIdKodiResponse(rsp)
}

func (c *ClientWithResponses) PostVideosVideoFileIdKodiWithResponse(ctx context.Context, videoFileId PathVideoFileId, body PostVideosVideoFileIdKodiJSONRequestBody, reqEditors ...RequestEditorFn) (*PostVideosVideoFileIdKodiResponse, error) {
	rsp, err := c.PostVideosVideoFileIdKodi(ctx, videoFileId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostVideosVideoFileIdKodiResponse(rsp)
}

// GetVideosVideoFileIdPlaylistWithResponse request returning *GetVideosVideoFileIdPlaylistResponse
func (c *ClientWithResponses) GetVideosVideoFileIdPlaylistWithResponse(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*GetVideosVideoFileIdPlaylistResponse, error) {
	rsp, err := c.GetVideosVideoFileIdPlaylist(ctx, videoFileId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVideosVideoFileIdPlaylistResponse(rsp)
}

// ParseGetChannelsResponse parses an HTTP response from a GetChannelsWithResponse call
func ParseGetChannelsResponse(rsp *http.Response) (*GetChannelsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChannelItems
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetChannelsChannelIdLogoResponse parses an HTTP response from a GetChannelsChannelIdLogoWithResponse call
func ParseGetChannelsChannelIdLogoResponse(rsp *http.Response) (*GetChannelsChannelIdLogoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChannelsChannelIdLogoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetConfigResponse parses an HTTP response from a GetConfigWithResponse call
func ParseGetConfigResponse(rsp *http.Response) (*GetConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Config
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDropLogsDropLogFileIdResponse parses an HTTP response from a GetDropLogsDropLogFileIdWithResponse call
func ParseGetDropLogsDropLogFileIdResponse(rsp *http.Response) (*GetDropLogsDropLogFileIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDropLogsDropLogFileIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetEncodeResponse parses an HTTP response from a GetEncodeWithResponse call
func ParseGetEncodeResponse(rsp *http.Response) (*GetEncodeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEncodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EncodeInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostEncodeResponse parses an HTTP response from a PostEncodeWithResponse call
func ParsePostEncodeResponse(rsp *http.Response) (*PostEncodeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostEncodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AddedEncode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteEncodeEncodeIdResponse parses an HTTP response from a DeleteEncodeEncodeIdWithResponse call
func ParseDeleteEncodeEncodeIdResponse(rsp *http.Response) (*DeleteEncodeEncodeIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteEncodeEncodeIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetIptvChannelM3u8Response parses an HTTP response from a GetIptvChannelM3u8WithResponse call
func ParseGetIptvChannelM3u8Response(rsp *http.Response) (*GetIptvChannelM3u8Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIptvChannelM3u8Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetIptvEpgXmlResponse parses an HTTP response from a GetIptvEpgXmlWithResponse call
func ParseGetIptvEpgXmlResponse(rsp *http.Response) (*GetIptvEpgXmlResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIptvEpgXmlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRecordedResponse parses an HTTP response from a GetRecordedWithResponse call
func ParseGetRecordedResponse(rsp *http.Response) (*GetRecordedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecordedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Records
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostRecordedResponse parses an HTTP response from a PostRecordedWithResponse call
func ParsePostRecordedResponse(rsp *http.Response) (*PostRecordedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostRecordedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreatedNewRecorded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostRecordedCleanupResponse parses an HTTP response from a PostRecordedCleanupWithResponse call
func ParsePostRecordedCleanupResponse(rsp *http.Response) (*PostRecordedCleanupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostRecordedCleanupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRecordedOptionsResponse parses an HTTP response from a GetRecordedOptionsWithResponse call
func ParseGetRecordedOptionsResponse(rsp *http.Response) (*GetRecordedOptionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecordedOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecordedSearchOptions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteRecordedRecordedIdResponse parses an HTTP response from a DeleteRecordedRecordedIdWithResponse call
func ParseDeleteRecordedRecordedIdResponse(rsp *http.Response) (*DeleteRecordedRecordedIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRecordedRecordedIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRecordedRecordedIdResponse parses an HTTP response from a GetRecordedRecordedIdWithResponse call
func ParseGetRecordedRecordedIdResponse(rsp *http.Response) (*GetRecordedRecordedIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecordedRecordedIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecordedItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteRecordedRecordedIdEncodeResponse parses an HTTP response from a DeleteRecordedRecordedIdEncodeWithResponse call
func ParseDeleteRecordedRecordedIdEncodeResponse(rsp *http.Response) (*DeleteRecordedRecordedIdEncodeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRecordedRecordedIdEncodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePutRecordedRecordedIdProtectResponse parses an HTTP response from a PutRecordedRecordedIdProtectWithResponse call
func ParsePutRecordedRecordedIdProtectResponse(rsp *http.Response) (*PutRecordedRecordedIdProtectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutRecordedRecordedIdProtectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePutRecordedRecordedIdUnprotectResponse parses an HTTP response from a PutRecordedRecordedIdUnprotectWithResponse call
func ParsePutRecordedRecordedIdUnprotectResponse(rsp *http.Response) (*PutRecordedRecordedIdUnprotectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutRecordedRecordedIdUnprotectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRecordingResponse parses an HTTP response from a GetRecordingWithResponse call
func ParseGetRecordingResponse(rsp *http.Response) (*GetRecordingResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecordingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Records
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostRecordingResettimerResponse parses an HTTP response from a PostRecordingResettimerWithResponse call
func ParsePostRecordingResettimerResponse(rsp *http.Response) (*PostRecordingResettimerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostRecordingResettimerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetReservesResponse parses an HTTP response from a GetReservesWithResponse call
func ParseGetReservesResponse(rsp *http.Response) (*GetReservesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReservesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Reserves
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostReservesResponse parses an HTTP response from a PostReservesWithResponse call
func ParsePostReservesResponse(rsp *http.Response) (*PostReservesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostReservesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AddedReserve
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetReservesCntsResponse parses an HTTP response from a GetReservesCntsWithResponse call
func ParseGetReservesCntsResponse(rsp *http.Response) (*GetReservesCntsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReservesCntsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReserveCnts
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetReservesListsResponse parses an HTTP response from a GetReservesListsWithResponse call
func ParseGetReservesListsResponse(rsp *http.Response) (*GetReservesListsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReservesListsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReserveLists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostReservesUpdateResponse parses an HTTP response from a PostReservesUpdateWithResponse call
func ParsePostReservesUpdateResponse(rsp *http.Response) (*PostReservesUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostReservesUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteReservesReserveIdResponse parses an HTTP response from a DeleteReservesReserveIdWithResponse call
func ParseDeleteReservesReserveIdResponse(rsp *http.Response) (*DeleteReservesReserveIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteReservesReserveIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetReservesReserveIdResponse parses an HTTP response from a GetReservesReserveIdWithResponse call
func ParseGetReservesReserveIdResponse(rsp *http.Response) (*GetReservesReserveIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReservesReserveIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReserveItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePutReservesReserveIdResponse parses an HTTP response from a PutReservesReserveIdWithResponse call
func ParsePutReservesReserveIdResponse(rsp *http.Response) (*PutReservesReserveIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutReservesReserveIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteReservesReserveIdOverlapResponse parses an HTTP response from a DeleteReservesReserveIdOverlapWithResponse call
func ParseDeleteReservesReserveIdOverlapResponse(rsp *http.Response) (*DeleteReservesReserveIdOverlapResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteReservesReserveIdOverlapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteReservesReserveIdSkipResponse parses an HTTP response from a DeleteReservesReserveIdSkipWithResponse call
func ParseDeleteReservesReserveIdSkipResponse(rsp *http.Response) (*DeleteReservesReserveIdSkipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteReservesReserveIdSkipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRulesResponse parses an HTTP response from a GetRulesWithResponse call
func ParseGetRulesResponse(rsp *http.Response) (*GetRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Rules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostRulesResponse parses an HTTP response from a PostRulesWithResponse call
func ParsePostRulesResponse(rsp *http.Response) (*PostRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AddedRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRulesKeywordResponse parses an HTTP response from a GetRulesKeywordWithResponse call
func ParseGetRulesKeywordResponse(rsp *http.Response) (*GetRulesKeywordResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRulesKeywordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuleKeywordInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostRulesKeywordResponse parses an HTTP response from a PostRulesKeywordWithResponse call
func ParsePostRulesKeywordResponse(rsp *http.Response) (*PostRulesKeywordResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostRulesKeywordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AddedRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteRulesRuleIdResponse parses an HTTP response from a DeleteRulesRuleIdWithResponse call
func ParseDeleteRulesRuleIdResponse(rsp *http.Response) (*DeleteRulesRuleIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRulesRuleIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRulesRuleIdResponse parses an HTTP response from a GetRulesRuleIdWithResponse call
func ParseGetRulesRuleIdResponse(rsp *http.Response) (*GetRulesRuleIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRulesRuleIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Rule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePutRulesRuleIdResponse parses an HTTP response from a PutRulesRuleIdWithResponse call
func ParsePutRulesRuleIdResponse(rsp *http.Response) (*PutRulesRuleIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutRulesRuleIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePutRulesRuleIdDisableResponse parses an HTTP response from a PutRulesRuleIdDisableWithResponse call
func ParsePutRulesRuleIdDisableResponse(rsp *http.Response) (*PutRulesRuleIdDisableResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutRulesRuleIdDisableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePutRulesRuleIdEnableResponse parses an HTTP response from a PutRulesRuleIdEnableWithResponse call
func ParsePutRulesRuleIdEnableResponse(rsp *http.Response) (*PutRulesRuleIdEnableResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutRulesRuleIdEnableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSchedulesResponse parses an HTTP response from a GetSchedulesWithResponse call
func ParseGetSchedulesResponse(rsp *http.Response) (*GetSchedulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchedulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Schedules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSchedulesBroadcastingResponse parses an HTTP response from a GetSchedulesBroadcastingWithResponse call
func ParseGetSchedulesBroadcastingResponse(rsp *http.Response) (*GetSchedulesBroadcastingResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchedulesBroadcastingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Schedules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSchedulesDetailProgramIdResponse parses an HTTP response from a GetSchedulesDetailProgramIdWithResponse call
func ParseGetSchedulesDetailProgramIdResponse(rsp *http.Response) (*GetSchedulesDetailProgramIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchedulesDetailProgramIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScheduleProgramItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSchedulesSearchResponse parses an HTTP response from a PostSchedulesSearchWithResponse call
func ParsePostSchedulesSearchResponse(rsp *http.Response) (*PostSchedulesSearchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSchedulesSearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ScheduleProgramItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSchedulesChannelIdResponse parses an HTTP response from a GetSchedulesChannelIdWithResponse call
func ParseGetSchedulesChannelIdResponse(rsp *http.Response) (*GetSchedulesChannelIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchedulesChannelIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Schedules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStoragesResponse parses an HTTP response from a GetStoragesWithResponse call
func ParseGetStoragesResponse(rsp *http.Response) (*GetStoragesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStoragesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StorageInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteStreamsResponse parses an HTTP response from a DeleteStreamsWithResponse call
func ParseDeleteStreamsResponse(rsp *http.Response) (*DeleteStreamsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStreamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStreamsResponse parses an HTTP response from a GetStreamsWithResponse call
func ParseGetStreamsResponse(rsp *http.Response) (*GetStreamsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStreamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StreamInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStreamsLiveChannelIdHlsResponse parses an HTTP response from a GetStreamsLiveChannelIdHlsWithResponse call
func ParseGetStreamsLiveChannelIdHlsResponse(rsp *http.Response) (*GetStreamsLiveChannelIdHlsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStreamsLiveChannelIdHlsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StartStreamInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStreamsLiveChannelIdM2tsResponse parses an HTTP response from a GetStreamsLiveChannelIdM2tsWithResponse call
func ParseGetStreamsLiveChannelIdM2tsResponse(rsp *http.Response) (*GetStreamsLiveChannelIdM2tsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStreamsLiveChannelIdM2tsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStreamsLiveChannelIdM2tsPlaylistResponse parses an HTTP response from a GetStreamsLiveChannelIdM2tsPlaylistWithResponse call
func ParseGetStreamsLiveChannelIdM2tsPlaylistResponse(rsp *http.Response) (*GetStreamsLiveChannelIdM2tsPlaylistResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStreamsLiveChannelIdM2tsPlaylistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStreamsLiveChannelIdM2tsllResponse parses an HTTP response from a GetStreamsLiveChannelIdM2tsllWithResponse call
func ParseGetStreamsLiveChannelIdM2tsllResponse(rsp *http.Response) (*GetStreamsLiveChannelIdM2tsllResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStreamsLiveChannelIdM2tsllResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStreamsLiveChannelIdMp4Response parses an HTTP response from a GetStreamsLiveChannelIdMp4WithResponse call
func ParseGetStreamsLiveChannelIdMp4Response(rsp *http.Response) (*GetStreamsLiveChannelIdMp4Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStreamsLiveChannelIdMp4Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStreamsLiveChannelIdWebmResponse parses an HTTP response from a GetStreamsLiveChannelIdWebmWithResponse call
func ParseGetStreamsLiveChannelIdWebmResponse(rsp *http.Response) (*GetStreamsLiveChannelIdWebmResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStreamsLiveChannelIdWebmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStreamsRecordedVideoFileIdHlsResponse parses an HTTP response from a GetStreamsRecordedVideoFileIdHlsWithResponse call
func ParseGetStreamsRecordedVideoFileIdHlsResponse(rsp *http.Response) (*GetStreamsRecordedVideoFileIdHlsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStreamsRecordedVideoFileIdHlsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StartStreamInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStreamsRecordedVideoFileIdMp4Response parses an HTTP response from a GetStreamsRecordedVideoFileIdMp4WithResponse call
func ParseGetStreamsRecordedVideoFileIdMp4Response(rsp *http.Response) (*GetStreamsRecordedVideoFileIdMp4Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStreamsRecordedVideoFileIdMp4Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStreamsRecordedVideoFileIdWebmResponse parses an HTTP response from a GetStreamsRecordedVideoFileIdWebmWithResponse call
func ParseGetStreamsRecordedVideoFileIdWebmResponse(rsp *http.Response) (*GetStreamsRecordedVideoFileIdWebmResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStreamsRecordedVideoFileIdWebmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteStreamsStreamIdResponse parses an HTTP response from a DeleteStreamsStreamIdWithResponse call
func ParseDeleteStreamsStreamIdResponse(rsp *http.Response) (*DeleteStreamsStreamIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStreamsStreamIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePutStreamsStreamIdKeepResponse parses an HTTP response from a PutStreamsStreamIdKeepWithResponse call
func ParsePutStreamsStreamIdKeepResponse(rsp *http.Response) (*PutStreamsStreamIdKeepResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutStreamsStreamIdKeepResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTagsResponse parses an HTTP response from a GetTagsWithResponse call
func ParseGetTagsResponse(rsp *http.Response) (*GetTagsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecordedTags
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostTagsResponse parses an HTTP response from a PostTagsWithResponse call
func ParsePostTagsResponse(rsp *http.Response) (*PostTagsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AddedRecordedTag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTagsTagIdResponse parses an HTTP response from a DeleteTagsTagIdWithResponse call
func ParseDeleteTagsTagIdResponse(rsp *http.Response) (*DeleteTagsTagIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTagsTagIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePutTagsTagIdResponse parses an HTTP response from a PutTagsTagIdWithResponse call
func ParsePutTagsTagIdResponse(rsp *http.Response) (*PutTagsTagIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutTagsTagIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTagsTagIdRelateResponse parses an HTTP response from a DeleteTagsTagIdRelateWithResponse call
func ParseDeleteTagsTagIdRelateResponse(rsp *http.Response) (*DeleteTagsTagIdRelateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTagsTagIdRelateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePutTagsTagIdRelateResponse parses an HTTP response from a PutTagsTagIdRelateWithResponse call
func ParsePutTagsTagIdRelateResponse(rsp *http.Response) (*PutTagsTagIdRelateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutTagsTagIdRelateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostThumbnailsResponse parses an HTTP response from a PostThumbnailsWithResponse call
func ParsePostThumbnailsResponse(rsp *http.Response) (*PostThumbnailsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostThumbnailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostThumbnailsCleanupResponse parses an HTTP response from a PostThumbnailsCleanupWithResponse call
func ParsePostThumbnailsCleanupResponse(rsp *http.Response) (*PostThumbnailsCleanupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostThumbnailsCleanupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostThumbnailsVideosVideoFileIdResponse parses an HTTP response from a PostThumbnailsVideosVideoFileIdWithResponse call
func ParsePostThumbnailsVideosVideoFileIdResponse(rsp *http.Response) (*PostThumbnailsVideosVideoFileIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostThumbnailsVideosVideoFileIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteThumbnailsThumbnailIdResponse parses an HTTP response from a DeleteThumbnailsThumbnailIdWithResponse call
func ParseDeleteThumbnailsThumbnailIdResponse(rsp *http.Response) (*DeleteThumbnailsThumbnailIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteThumbnailsThumbnailIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetThumbnailsThumbnailIdResponse parses an HTTP response from a GetThumbnailsThumbnailIdWithResponse call
func ParseGetThumbnailsThumbnailIdResponse(rsp *http.Response) (*GetThumbnailsThumbnailIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetThumbnailsThumbnailIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetVersionResponse parses an HTTP response from a GetVersionWithResponse call
func ParseGetVersionResponse(rsp *http.Response) (*GetVersionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Version
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostVideosUploadResponse parses an HTTP response from a PostVideosUploadWithResponse call
func ParsePostVideosUploadResponse(rsp *http.Response) (*PostVideosUploadResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostVideosUploadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteVideosVideoFileIdResponse parses an HTTP response from a DeleteVideosVideoFileIdWithResponse call
func ParseDeleteVideosVideoFileIdResponse(rsp *http.Response) (*DeleteVideosVideoFileIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVideosVideoFileIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetVideosVideoFileIdResponse parses an HTTP response from a GetVideosVideoFileIdWithResponse call
func ParseGetVideosVideoFileIdResponse(rsp *http.Response) (*GetVideosVideoFileIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVideosVideoFileIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetVideosVideoFileIdDurationResponse parses an HTTP response from a GetVideosVideoFileIdDurationWithResponse call
func ParseGetVideosVideoFileIdDurationResponse(rsp *http.Response) (*GetVideosVideoFileIdDurationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVideosVideoFileIdDurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VideoFileDuration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostVideosVideoFileIdKodiResponse parses an HTTP response from a PostVideosVideoFileIdKodiWithResponse call
func ParsePostVideosVideoFileIdKodiResponse(rsp *http.Response) (*PostVideosVideoFileIdKodiResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostVideosVideoFileIdKodiResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetVideosVideoFileIdPlaylistResponse parses an HTTP response from a GetVideosVideoFileIdPlaylistWithResponse call
func ParseGetVideosVideoFileIdPlaylistResponse(rsp *http.Response) (*GetVideosVideoFileIdPlaylistResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVideosVideoFileIdPlaylistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}
